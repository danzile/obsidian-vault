# Module 326 & 306
## Danilo Anzile

Module du 11. 10 .202 1 au 29.10. 2020


## Table des matières I


Table des matières II


- 1 Introduction et contexte de l’application Table des matières
   - 1. 1 Description du projet
   - 1.2 Cahier des charges
- 2 Analyse des besoins
   - 2.1 Introduction
      - 2.1.1 Périphériques utilisés pour l’application.
      - 2.1.2 Diagramme de cas d’utilisation
   - 2.2 Applications serveur
      - 2.2.1 Cas d’utilisation serveur
      - 2.2.2 Descriptions des acteurs
      - 2.2.3 Descriptions des cas d’utilisations
      - 2.2.4 Maquettes serveurs avec navigation des différents écrans
      - 2.2.5 Diagrammes de séquences et d’activités principaux serveur.
         - a) Diagramme de séquence concernant la connexion de l’utilisateur.
         - b) Diagramme de séquence concernant le mouvement du robot.
   - 2.3 Applications client
      - 2.3.1 Cas d’utilisation client..........................................................................................
      - 2.3.2 Descriptions des acteurs
      - 2.3.3 Descriptions des cas d’utilisations
      - 2.3.4 Maquettes client avec navigation des différents écrans.....................................
      - 2.3.5 Diagrammes d’activités principaux client............................................................
         - a) Diagramme d’activité concernant la connexion de l’utilisateur.
         - b) Diagramme de séquence concernant le mouvement du robot.
   - 2.4 Base de données
   - 2.5 Conclusion de l'analyse avec liste des tests technologiques à faire...................
         - a) Tests technologiques :
- 3 Tests technologiques
   - 3.1 Introduction
   - 3.2 Tests technologiques de base
      - 3.2.1 Les Threads
         - a) C’est quoi?
         - b) Lancement d’un thread.................................................................................
         - c) Modes de thread...........................................................................................
         - d) Exercice
         - e) Exercice
      - 3.2.2 Communication Bluetooth
      - 3.2.3 Application TCP/IP client-serveur
         - a) Exercice 12 :
      - 3.2.4 Image et vidéo (avec webcam et transport client-serveur)
      - 3.2.5 Remarques et commentaires sur les tests de base
   - 3.3 Tests technologiques du côté client
      - 3.3.1 Manette XBOX
         - a) Explication du problème
         - b) Source projet de tests
         - c) Remarques et commentaires sur le test
         - etc.. une synthèse du test technologique. d) Remarques pertinentes, à quoi il faut faire attention, configuration spéciale
      - 3.3.2 Kinect
         - a) Explication du problème
         - b) Source projet de tests
         - c) Remarques et commentaires sur le test
         - d) Fonctionnalité possible avec J4K
         - e) Récupérer flux vidéo
   - 3.4 Tests technologiques du côté serveur
      - 3.4.1 7Links
         - a) Explication du problème
         - b) Source projet de tests
         - c) Remarques et commentaires sur le test
         - etc.. une synthèse du test technologique. d) Remarques pertinentes, à quoi il faut faire attention, configuration spéciale
   - 3.5 Conclusion sur les tests technologiques
- 4 Spécificités matérielles........................................................................................................
- 5 Spécificités logicielles
- 6 Conception
   - 6.1 Introduction
      - 6.1.1 Thread
      - 6.1.2 Interface.............................................................................................................
   - 6.2 Application client
      - 6.2.1 Diagramme de classes MVC2 de l’application
      - 6.2.2 Diagramme de classes Ihm
      - 6.2.3 Diagramme de classes Wrk
      - 6.2.4 Diagramme de classes Beans
   - 6.3 Application serveur
      - 6.3.1 Diagramme de classes MVC2 de l’application
      - 6.3.2 Diagramme de classes Ihm
      - 6.3.3 Diagramme de classes Wrk
      - 6.3.4 Diagramme de classes Beans
   - 6.4 Modèle de la base de données
   - 6.5 Conclusion
- 7 Implémentation
   - 7.1 Reverse engineering client
      - 7.1.1 Diagramme de classes MVC2 (client)
      - 7.1.2 Diagramme de classes Ihm (client)
      - 7.1.3 Diagramme de classes Wrk (client)
      - 7.1.4 Diagramme de classes Beans (client)
   - 7.2 Reverse engineering serveur
      - 7.2.1 Diagramme de classes MVC2 (serveur)
      - 7.2.2 Diagramme de classes Ihm (serveur)
      - 7.2.3 Diagramme de classes Wrk (serveur)
      - 7.2.4 Diagramme de classes Beans (serveur)
   - 7.3 Remarques et commentaires
      - l’analyse des besoins et l'implémentation) 7.3.1 Particularités de l’application (divergence avec le cahier des charges et
   - 7.4 Erreurs rencontrées avec solution Table des matières III
      - 7.4.1 1. Liens avec la Kinect (Client)
      - 7.4.2 2. IHM mainView (Client)
   - 7.5 Erreurs résiduelles avec pistes de solutions
      - 7.5.1 3.Flux vidéo de la Kinect
- 8 Autoévaluation
   - 8.1 Autoévaluation de l’apprenti (Danilo)
   - 8.2 Autoévaluation de l’apprenti (Joel)
   - 8.3 Autoévaluation de l’équipe de développement
- 9 Conclusion
   - 9.1 Conclusion de l’apprenti (Danilo)
   - 9.2 Conclusion de l’apprenti (Joel)
   - 9.3 Conclusion de l’équipe de développement
- 10 Annexes
   - 10.1 Annexe 1 : Journal de travail
   - 10.2 Annexe 2 : Planning....................................................................................................
   - 10.3 Annexe 3 : ToDoList
   - 10.4 Annexe 4: Exercices
      - 10.4.1 Exercice 1 :
      - 10.4.2 Exercice 2 :
      - 10.4.3 Exercice 3 :
      - 10.4.4 Exercice 4 :
      - 10.4.5 Exercice 5 :
      - 10.4.6 Exercice 6 :
      - 10.4.7 Exercice 7 :
      - 10.4.8 Exercice 8 :
      - 10.4.9 Exercice 11 :


Anzile Danilo Page 1 sur 63

## 1 Introduction et contexte de l’application

Cette application a pour but de contrôler un robot, à l’aide d’une manette de console.
L’application permet à un visiteur de créer un compte avec fonction de reconnaissance faciale,
piloter le robot à l’aide de la manette, prendre des captures de la vidéo diffusé par le robot. Les
administrateurs ont l’option de gérer les utilisateurs.

### Robot Manette

```
Source Source
```
### Kinect Base de données

```
Source Source
```
### 1. 1 Description du projet

Notre projet consiste à faire une application qui permet de gérer le robot. Chaque utilisateur
aura son propre compte. Il pourra se loger de différentes façons. La plus simple est avec un
nom d’utilisateur et un mot de passe tandis que la façon plus intéressante et en utilisant la
Kinect et faire de la reconnaissance faciale.


### 1.2 Cahier des charges

- Page de login
- Reconnaissance faciale avec Kinect
- Base de données
- Capture d’image / vidéo du robot
- Gestion des mouvements du robot avec manette

## 2 Analyse des besoins

### 2.1 Introduction

On aura besoin d’une Kinect pour tout ce qui touche au login de l’utilisateur pour la
reconnaissance facial. Une manette qui permet de contrôler le robot et de le faire bouger. Une
base de données qui permet de gérer les utilisateurs. Et logiquement un robot.

#### 2.1.1 Périphériques utilisés pour l’application.

1. Manette XBOX
2. Robot « 7Links HSR- 1 »
3. Base de données
4. Kinect

#### 2.1.2 Diagramme de cas d’utilisation

Le diagramme de cas d’utilisation de nos deux applications est le suivant :


### 2.2 Applications serveur

#### 2.2.1 Cas d’utilisation serveur

Diagramme de cas d’utilisations de l’application côté serveur, les différents acteurs et leurs
actions sont présente dans les chapitres suivants.

```
uc Use Case Client-Server
Client TCP / UDP Server
```
```
Visitor
```
```
User
```
```
S'enregistrer
```
```
Connexion
```
```
Vérification
```
```
Base de données
```
```
Reconnaissance facial
Administrateur
```
```
Gérer accès
```
```
Enregistrer utilisateur
```
```
Manette Xbox
```
```
Bluetooth
Wi-Fi
```
```
7Links
```
```
Connection Controller
```
```
Controller Action
```
```
Pilotage
```
```
Logout
Logout
```
```
Live Streaming
```
```
Video
```
```
Record/Save Video
```
```
Stop d'urgence
ConnectionRobot
```
```
Robot start
```
```
Kinect
```
```
Kinnectmodel Use Case Client
Danilo Anzile & Joel Neuhaus
Version 2.005.11.2021 «invokes»
```
```
«invokes»
```
```
«use»Use
```
```
«invokes»
```
```
«invokes»
```
```
«invokes»
```
```
«invokes»
```
```
«Include»Include
```
```
«invokes»
```
```
«invokes»
```
```
«include»Include
```
```
Include«include»
```

#### 2.2.2 Descriptions des acteurs

```
Acteurs Description
```
```
Client Le client le robot. L’administrateur utilise cette interface pour représente^ l’interface que l’utilisateur utilise pour pouvoir utiliser gérer les utilisateurs.
```
```
Base de données
```
```
La base de données est l’endroit dans lequel les informations des
utilisateurs sont stockées.
```
```
Administrateur
```
```
L’administrateur est l’utilisateur pouvant gérer tous les autres utilisateurs
et leurs droits, il peut aussi en ajouter, les modifier ou les supprimer. Il
peut aussi effectuer manuellement la connexion à la base de données et
au Sumo.
```
```
Robot
```
```
C’est un robot qui est contrôlé par une manette. Il peut rouler et prendre
des vidéos.
```
#### 2.2.3 Descriptions des cas d’utilisations

```
Acteurs Description
```
```
Base de données
```
```
Vérification : Vérifie sur la base de données si les informations d’un
utilisateur correspondent à un utilisateur de la base de données.
Logout : Déconnecte l’utilisateur de la base de données.
```
```
Administrateur
```
```
Gérer accès : L’administrateur est l’utilisateur pouvant gérer tous les
autres utilisateurs et leurs droits, il peut aussi en ajouter, les modifier ou
les supprimer.
Robot Stop d’urgence : La connexion avec le sumo est coupée.
```
```
uc Server
Server
```
```
Vérification
```
```
Base de données
```
```
Administrateur
```
```
Gérer accès
```
```
Enregistrer utilisateur
```
```
Wi-Fi
```
```
7Links
Pilotage
```
```
Logout
```
```
Live Streaming
```
```
Stop d'urgence
```
```
Robot start
```
```
Client
```
```
Kinnectmodel Use Case Client
Danilo Anzile & Joel NeuhausVersion 2.
05.11.
```
```
«include»Include
```

```
Live streaming : Le Robot transmet une vidéo en direct à l’utilisateur.
Robot start : le Robot est démarré par l’utilisateur quand il se sera
connecté.
Pilotage : Le robot est piloté par l’utilisateur à l’aide d’une manette
```
#### 2.2.4 Maquettes serveurs avec navigation des différents écrans

La première fenêtre qui s’affiche lors du lancement de l’application est la fenêtre de connexion.
Cette fenêtre nous permet de nous connecter uniquement aux utilisateurs admin de la base de
données. Si la connexion échoue un pop-up s’affichera expliquant l’erreur survenue. Si la
connexion se passe sans erreur on accède à une autre fenêtre qui nous permet d’accéder à
tous les paramètres de l’application client. Il est possible de se connecter ou déconnecter au
robot ou à la base de données, il est aussi possible d’ajouter des nouveaux utilisateurs a la
base de données, de les modifier ou de les supprimer. Finalement on a aussi accès a des
informations comme les log actions, les actions effectuées sur la base de données et le nom
des utilisateurs qui se sont connectées à l’application client.

#### 2.2.5 Diagrammes de séquences et d’activités principaux serveur.

##### a) Diagramme de séquence concernant la connexion de l’utilisateur.

Diagramme de séquence montrant une connexion a une base de données.

```
ui Maquettes Server
KinnectMaquette Client
Danilo Anzile & Joel NeuhausVersion 2.
29.11.2021 Konnect - Server Login
```
```
Username:
Password:
Login Quit
```
```
Konnect - Login error
Error...
```
```
Back
```
```
Konnect - Server Manager
```
```
Log Action Database Action Login's
```
```
Robot Database
```
```
Emergency stop
```
```
Live
```
```
Connect Disconnect
```
```
Connect Database DisconnectDatabase
```
```
User Management
Userlist
```
```
Add
```
```
Username:
Password:
Admin
```
```
Edit Delete
```
```
Si erreur connection reusite
```

##### b) Diagramme de séquence concernant le mouvement du robot.

Ce diagramme de séquence montre le déroulement des actions faites lorsque l’utilisateur utilise
la manette pour faire bouger le robot.

```
sd Séquences spécifique de connection
```
```
User
```
```
Client
```
```
Kinnect
Diagramme de sequence de connection
Danilo Anzile & Joel Neuhaus
Version 1.
01.11.
```
```
Server Da ta ba se
```
```
crea teUser(String userna me, String
pa ssword)
```
```
sendUser(User user):
boolea n
```
```
notExist():
boolea n
```
```
a ddUser(User user):
boolea n
```
```
da ta Trea tment
()
```
```
isConnected():
boolea n
```
```
registerAsUser
()
```
```
displa ySuccess
()
```
```
isConnected
(): boolea n
```
```
a ddOk()
```

### 2.3 Applications client

#### 2.3.1 Cas d’utilisation client..........................................................................................

Diagramme de cas d’utilisations de l’application côté client, les différents acteurs et leurs
actions sont présente dans les chapitres suivants.

```
sd Séquences spécifiques de mouvement de robot
KinnectDiagramme de sequence de
mouvement du robotDanilo Anzile & Joel Neuhaus
Version 2.005.11.2021 User Controller
```
```
Client Server Robot
```
```
Needed status:Server: connected
Database: connected
Error: connection robot
```
```
Error: Can't move
transmitAction(Action action): boolean
```
```
move()
```
```
createAction(): action
```
```
:ready
```
```
actionOk(): boolean
```
```
pilotingStart()
```
```
connectController(): boolean
```
```
robotReady()
```
```
startRobot()
```
```
wait()
```
```
transmitNewPosition()
```
```
piloting()
```
```
turnOnRobot()
```
```
uc Client
Client
```
```
Visitor
```
```
User
```
```
S'enregistrer
```
```
Connexion
```
```
Reconnaissance facial
```
```
Manette Xbox
```
```
Bluetooth Connection Controller
```
```
Controller Action
```
```
Logout
```
```
Record/Save Video
Video
```
```
ConnectionRobot
```
```
Kinect
Serveur
```
```
Kinnectmodel Use Case Client
Danilo Anzile & Joel Neuhaus
Version 2.005.11.2021 «Include»Include
```
```
«use»Use
```
```
«include»Include
```

```
Le client est composé d’une caméra qui permet de faire la connexion avec le serveur, d’un
utilisateur qui interagie avec le robot via la manette de Xbox. Chaque mouvement de la manette
est envoyé au serveur.
```
#### 2.3.2 Descriptions des acteurs

```
Acteur Description
Visitor Le visiteur a comme seule option d’enregistrer un compte utilisateur.
Kinect La Kinect permet de se connecter en tant qu’utilisateur en utilisant la
reconnaissance faciale.
User L’utilisateur peut se connecter et déconnecter. Lorsque l’utilisateur est connecté
il peut piloter le robot et faire des captures.
Manette La manette est un périphérique qui permet de piloter le robot.
Serveur Le serveur est la partie qui s’occupera de la communication avec le Robot est la
base de données.
```
#### 2.3.3 Descriptions des cas d’utilisations

```
Acteurs Description
Visitor Connexion^ :^ l’utilisateur doit se connecter au serveur.^
S’enregistrer : le visiteur peut créer un compte afin de devenir utilisateur.
Kinect Reconnaissance faciale : Permets aux utilisateurs de se connecter.
```
```
User
```
```
Logout : permet à l’utilisateur de se déconnecter.
Record vidéo : l’utilisateur peut regarder et enregistrer les vidéos transmises
par le Robot.
Robot connexion : l’utilisateur se connecte au robot.
```
```
Manette
```
```
Connexion contrôleur : la connexion de la manette se fait par l’utilisateur.
Controller Action : les actions effectuées par la manette sont transmises au
serveur afin de piloter le drone.
```
#### 2.3.4 Maquettes client avec navigation des différents écrans.....................................

La première fenêtre qui s’affiche lors du lancement de l’application est une fenêtre d’accueil
contenant une image et deux boutons permettant de se connecter à un compte ou d’en créer
un. Si on utilise le bouton de connexion on sera redirigé sur une page permettant de se
connecter à la base de données. Cette page nous permet aussi de sélectionner le bouton
« Face ID », qui nous redirige vers une page permettant de se connecter à son compte en
utilisant la reconnaissance faciale. Si on clique sur « Register » sur le page d’accueil un sera
redirigé sur une page très similaire à celle du login, mais celle si vas créer un nouvel utilisateur
dans la base de données.
Lorsqu’on est connecté à la base de données l’utilisateur est redirigé vers une page permettant
de voir la vue du robot. Il sera possible de piloter le robot avec la manette dès ce moment et si
cela ne fonctionne pas, il est possible de se reconnecter au robot ou à la manette en cliquant
sur « Refresh ». Cette fenêtre permet aussi de prendre des captures d’écran.


#### 2.3.5 Diagrammes d’activités principaux client............................................................

##### a) Diagramme d’activité concernant la connexion de l’utilisateur.

Ce diagramme d’activité montre le déroulement de l’enregistrement d’un nouvel utilisateur
depuis l’application cliente.

```
ui Maquettes Client
KinnectMaquette Client
Danilo Anzile & Joel NeuhausVersion 1.
01.11.
```
```
Konnect
```
```
Login Register
```
```
Image
```
```
Konnect - Login
Username:
Password:
Login
```
```
Face ID
Back
```
```
Konnect - Face ID
Video Kinect
```
```
Login Back
```
```
Konnect - Client view
Video Robot
```
```
Take Picture Logout
```
```
Konnect - Screenshot
Screenshot
```
```
Konnect - Register
```
```
Username
Password
Confirmepassword
```
```
Submit
```
```
Configure Face ID
```
```
Konnect - Configuration Face ID
Video Kinect
```
```
Take 10 pictures of yourself
Take picture
```
```
Save Delete
```
```
Konnect - Register error
Erreur...
```
```
Back
```
```
Konnect - Login error
Erreur...
```
```
Back
```
```
File Path: ...
```
```
Status:
Controler:Robot: ConnectedConnected
```
```
Refresh
```

##### b) Diagramme de séquence concernant le mouvement du robot.

Ce diagramme d’activité montre le déroulement lorsqu’on se connecte au robot.

### 2.4 Base de données

Pour pouvoir stocker les utilisateurs et les images permettant la reconnaissance faciale, il est
nécessaire de faire une base de données. Pour avoir une idée claire de la base de données
nous avons commencé par faire un schéma Visio.
Pour cette base de données deux tables étaient nécessaires. La première contenant les
informations des utilisateurs telles que le nom d’utilisateur, le mot de passe ou encore si
l’utilisateur est un admin ou pas. Sur la deuxième table on stocke les photos propres à chaque
utilisateur, permettant la reconnaissance faciale.

```
act Activités spécifique de connection
Visitor G2-Robot Client G2-Robot Server Database
```
```
PressLogin
```
```
RegistrerPress
```
```
Connected?Server
```
```
Create User
```
```
Send Connection Request Request
Sent?
```
```
Show Error Message
```
```
Send User
```
```
Display Success Message
```
```
Recieve User
```
```
ClientLoad
View
```
```
Send Success Message
```
```
Send Success Message
```
```
Recieve Connection Request
```
```
Error
```
```
ConnectServer
```
```
Connection
```
```
Send Connection Request
```
```
DatabaseConnect Show Error Message RequestSent?
```
```
Recive Message
```
```
Send User
```
```
Recieve Message
```
```
Send Success Message
```
```
PasswordOK?
```
```
Add User
Added?User
```
```
Recieve User
```
```
Connection
```
```
Show Error Message
```
```
KinnectDiagramme d'activités de
connectionDanilo Anzile & Joel
NeuhausVersion 2.
5.11.2021 Face ID ok?
```
```
Nok
```
```
OK
```
```
Nok Ok
```
```
Nok
```
```
Nok
```
```
ok
```
```
Ok
```
```
Nok
```
```
Nok
```
```
Ok?
```
```
act Activités spécifique Deux
Robot
```
```
Controller
```
```
User G2-Robot Client G2-Robot Server
KinnectDiagramme
d'activités deuxDanilo Anzile & Joel
NeuhausVersion 1.
01.11.
```
```
Press PilotingStart
```
```
Piloting Start Press ConnectController
```
```
Robot Connected
```
```
Send Connection Request Recieve Connection Request
```
```
Send Connection Request
Requeste Sent? Connection
```
```
Connect Recieve Error Message Send Error Message
Robot
Send Success Message
```
```
Display Success Message Use Controler
```
```
Send Connection Request
```
```
Recive Success Message
```
```
Send Action
Create Action
Recive Action
```
```
Connection Move Joystick / Press Button
```
```
Recive Action Send Action Move Wait for
new action
```
```
Recive Message
```
```
Nok
```
```
Ok
```
```
Nok
```
```
Ok
```
```
Nok
```

Après avoir fait un schéma Visio nous avons recréer le schéma et puis crée la base de données
sur MySQL Workbench.

Nous avons directement créé un utilisateur Admin pouvant accéder à l’application server pour
effecteur les tests.

Pour les tests suivants nous avons aussi créé un utilisateur non-admin.


### 2.5 Conclusion de l'analyse avec liste des tests technologiques à faire...................

Ce projet nécessite un grand nombre de tests technologiques comme pour le robot ou la
manette, mais aussi des protocoles comme le protocole TCP ou le UDP.

##### a) Tests technologiques :

1. Connexion au 7Links
2. Connexion Bluetooth à la manette XBOX
3. Connexion TCP/IP
4. Connexion UDP
5. Connexion USB à la Kinect

## 3 Tests technologiques

### 3.1 Introduction

Les tests technologiques permettent de comprendre le matériel à utiliser pour le projet.
Pour débuter nous devons tester de manière générale les Thread, TCP/IP, Bluetooth et WIFI.
Puis on devait tester le matériel propre à notre matériel comme la Kinect, La manette XBOX ou
le robot 7Links.

### 3.2 Tests technologiques de base

#### 3.2.1 Les Threads

##### a) C’est quoi?

Un thread a comme fonctionnalité d’exécuter plusieurs traitements en même temps.

##### b) Lancement d’un thread.................................................................................

Pour lancer un thread sur netbeans il faut utiliser le bouton affiché en dessous.

Il est important de savoir que plusieurs Threads sont créés par default dans le projet, dans
l’exemple du bas les seuls threads crées par nous sont les deux derniers.


##### c) Modes de thread...........................................................................................

Les deux modes les plus importants sont Running (actif) et Sleeping (en veille).

d) Exercice 9

1. Ouvrir et étudier le projet EA fourni :
2. Tester le programme fourni et visualiser les Thread exécutés dans NetBeans
    Les threads sont affichés en dessous.
3. Code pour un thread chrono
Les threads sont créés lorsqu’on crée des objets héritant de la classe « thread ».


public boolean demarreThreads() {
boolean ok = false;

L’if suivant crée et lance un chrono si cela n’est pas déjà fait et mets le boolean crée
précédemment en true.

if (chrono == null) {
chrono = new ChronoThread("Chrono", this);
chrono.start();
ok = true;
}

L’if suivant permet de créer une nouvelle activité su le chrono est lancée.

if (ok) {
if (activity == null) {
activity = new ActivityThread("Activity", this);
activity.start();
activity.startActivity();
ok = true;
}
}
return ok;
}

e) Exercice 10

```
I.Ouvrir et étudier le projet EA fourni
class pattern
```
```
«interface» ItfIhmCtrl
+ + afficheDateCourante(String): voidafficheDistance(int, int, int): void
+ + afficheFinCourse(): voidafficheFinCourseCoureur(int, int, String): void
+ + afficheFinCourseEquipe(int, String): voidafficheInfo(String): void
+ + afficheTempsChrono(String): voidinitialiseTextCoureur(): void
+ toggleBoutonStart(boolean): void
```
```
Ihm javax.swing.JFrame
```
- - bDemarreThreads: javax.swing.JButtonbDetruitThreads: javax.swing.JButton
- - bPause: javax.swing.JButtonbStart: javax.swing.JButton
- - jScrollPane1: javax.swing.JScrollPanelCoureur1_1: javax.swing.JLabel
- - lCoureur1_2: javax.swing.JLabellCoureur1_3: javax.swing.JLabel
- - lCoureur1_4: javax.swing.JLabellCoureur2_1: javax.swing.JLabel
- - lCoureur2_2: javax.swing.JLabellCoureur2_3: javax.swing.JLabel
- - lCoureur2_4: javax.swing.JLabellCoureur3_1: javax.swing.JLabel
- - lCoureur3_2: javax.swing.JLabellCoureur3_3: javax.swing.JLabel
- - lCoureur3_4: javax.swing.JLabellCoureur4_1: javax.swing.JLabel
- - lCoureur4_2: javax.swing.JLabellCoureur4_3: javax.swing.JLabel
- - lCoureur4_4: javax.swing.JLabellEquipe1: javax.swing.JLabel
- - lEquipe2: javax.swing.JLabellEquipe3: javax.swing.JLabel
- - lEquipe4: javax.swing.JLabelliste: javax.swing.JList
- - lTitreListe: javax.swing.JLabelmodel: DefaultListModel
- - panelEquipe1: javax.swing.JPanelpanelEquipe2: javax.swing.JPanel
- - panelEquipe3: javax.swing.JPanelpanelEquipe4: javax.swing.JPanel
- - panelGeneral: javax.swing.JPanelpbCoureur1_1: javax.swing.JProgressBar
- - pbCoureur1_2: javax.swing.JProgressBarpbCoureur1_3: javax.swing.JProgressBar
- - pbCoureur1_4: javax.swing.JProgressBarpbCoureur2_1: javax.swing.JProgressBar
- - pbCoureur2_2: javax.swing.JProgressBarpbCoureur2_3: javax.swing.JProgressBar
- - pbCoureur2_4: javax.swing.JProgressBarpbCoureur3_1: javax.swing.JProgressBar
- - pbCoureur3_2: javax.swing.JProgressBarpbCoureur3_3: javax.swing.JProgressBar
- - pbCoureur3_4: javax.swing.JProgressBarpbCoureur4_1: javax.swing.JProgressBar
- - pbCoureur4_2: javax.swing.JProgressBarpbCoureur4_3: javax.swing.JProgressBar
- - pbCoureur4_4: javax.swing.JProgressBarrefCtrl: ItfCtrlIhm
- - tChrono: javax.swing.JTextFieldtHorloge: javax.swing.JTextField
+ + afficheDateCourante(String): voidafficheDistance(int, int, int): void
+ + afficheFinCourse(): voidafficheFinCourseCoureur(int, int, String): void
+ + afficheFinCourseEquipe(int, String): voidafficheInfo(String): void
+ - afficheTempsChrono(String): voidbDemarreThreadsActionPerformed(java.awt.event.ActionEvent): void
- - bDetruitThreadsActionPerformed(java.awt.event.ActionEvent): voidbPauseActionPerformed(java.awt.event.ActionEvent): void
- + bStartActionPerformed(java.awt.event.ActionEvent): voidgetRefCtrl(): ItfCtrlIhm
+ - Ihm()initComponents(): void
+ + initialiseTextCoureur(): voidinitIhmCourse(): void
+ + setRefCtrl(ItfCtrlIhm): voidtoggleBoutonStart(boolean): void

```
«interface» ItfCtrlWrk
+ + coureurTermineCourse(int, int, String): voidequipeArrive(int, String): void
+ + finCourse(): voidrecoitDateCourante(String): void
+ + recoitDistanceCoureur(int, int, int): voidrecoitTempsChrono(String): void
```
```
«interface» ItfCtrlIhm
+ + demarreCourse(): voiddemarreThreads(): void
+ + detruitThreads(): voidpauseCourse(): void
```
```
Ctrl
```
- - pauseAffichage: booleanrefIfm: ItfIhmCtrl
- refWrk: ItfWrkCtrl
+ + coureurTermineCourse(int, int, String): voiddemarreCourse(): void
+ + demarreThreads(): voiddetruitThreads(): void
+ + equipeArrive(int, String): voidfinCourse(): void
+ + getRefIfm(): ItfIhmCtrlgetRefWrk(): ItfWrkCtrl
+ + pauseCourse(): voidrecoitDateCourante(String): void
+ + recoitDistanceCoureur(int, int, int): voidrecoitTempsChrono(String): void
+ + setRefIfm(ItfIhmCtrl): voidsetRefWrk(ItfWrkCtrl): void
+ start(): void

```
Main
+ main(String[]): void
```
```
Chrono
```
- - course: Coursestart: long
+ + Chrono(Course)demarrer(): void
+ run(): void

```
Coureur
```
- - coureur: intcourseEquipe: CourseEquipe
- distance: int = 0
+ + Coureur(CourseEquipe, int)run(): void

```
Course
```
- - chrono: ChronocourseEquipes: CourseEquipe ([])
- - refWrk: ItfWrkCoursetemps: String
~ + coureurTermine(int, int): voidCourse(ItfWrkCourse)
+ ~ demarrer(): voidequipeTermine(int): void
~ ~ recoitDistanceCoureur(int, int, int): voidrecoitTemps(String): void
+ run(): void

```
CourseEquipe
```
- - c: Coureur ([])COUREURS: int = 4 {readOnly}
- ~ course: Courseequipe: int
+ + CourseEquipe(int, Course)demarrer(): void
+ + getEquipe(): intrecoitDistanceCoureur(int, int): void
+ run(): void

```
Horloge
```
- - df: DateFormatrefWrk: ItfWrkCtrl
+ + Horloge(ItfWrkCtrl)run(): void

```
SThread Thread
```
- - paused: volatile boolean = truerunning: volatile boolean = false
+ + isPaused(): booleanisRunning(): boolean
+ + pause(int): voidsetPaused(boolean): void
+ + setRunning(boolean): voidSThread()
+ SThread(String)

```
ItfWrkCourse «interface»
+ + coureurTermine(int, int, String): voidequipeArrive(int, String): void
+ + finCourse(): voidrecoitDistanceCoureur(int, int, int): void
+ recoitTemps(String): void
```
```
«interface» ItfWrkCtrl
+ + demarreCourse(): voiddemarreHorloge(): void
+ + demarreThreads(): voiddetruitThreads(): void
+ + prepareCourse(): voidrecoitDateEtHeure(String): void
```
```
Wrk
```
- - course: Coursehorloge: Horloge
- refCtrl: ItfCtrlWrk
+ + coureurTermine(int, int, String): voiddemarreCourse(): void
+ + demarreHorloge(): voiddemarreThreads(): void
+ + detruitThreads(): voidequipeArrive(int, String): void
+ + finCourse(): voidgetRefCtrl(): ItfCtrlWrk
+ + prepareCourse(): voidrecoitDateEtHeure(String): void
+ + recoitDistanceCoureur(int, int, int): voidrecoitTemps(String): void
+ + setRefCtrl(ItfCtrlWrk): voidWrk()

```
+refWrk
```
```
+refIfm
```
```
-refCtrl
+refWrk
```
```
-course
-courseEquipes
```
```
-chrono
```
```
-courseEquipe
```
```
+refWrk
```
```
-horloge
```
```
-refCtrl
```
```
-course
```
```
-c
```
```
-course
```

```
II.Tester le programme fourni et visualiser les Thread exécutés dans NetBeans
```
#### 3.2.2 Communication Bluetooth

Avant de pouvoir communiquer en Bluetooth il faut connecter une clé Bluetooth au PC.

Ensuite il faut se rendre dans les paramètres Bluetooth avancées pour autoriser les autres
périphériques à détecter ce PC.


Si le PC auquel vous voulez vous connecter a suivi les mêmes étapes que vous, il sera
détectable dans les paramètres Bluetooth en cliquant sur « Ajouter un appareil Bluetooth ou un
autre appareil ».

Puis il faut cliquer sur Bluetooth.


Lorsque vous cliquez sur un des périphériques affichées une demande de connexion sera
effectuée.

Il est nécessaire de confirmer la connexion sur le deuxième PC.


Une fois les deux PC connectées il est nécessaire d’attribuer un port COM au PC auquel on
s’est connectée, ceci nous permet ensuite de faire communiquer les deux PC sur une
application Java.
Pour attribuer un port COM à un PC il est nécessaire de le faire dans le gestionnaire de
périphériques.


Résultat attendu :

#### 3.2.3 Application TCP/IP client-serveur

##### a) Exercice 12 :

Diagramme de séquence de l’exercice.


Pour un ordinateur le projet client et pour l'autre le projet serveur, faire :

1. Tester la communication avec l'autre ordinateur selon le projet que vous avez installé
2. Code important Serveur
    a. Démarrage du serveur
Pour pouvoir démarrer le serveur sur un port, il faut instancier l’objet nommée « ServerSocket ».

public void demarrerServeur(int port) {
try {
serverSocket = new ServerSocket(port);
serverSocket.setSoTimeout(1000);
wrk.recevoirMessageInfo("Serveur démarré");
} catch (IOException ex) {
wrk.recevoirMessageInfo("Erreur dans le démarrage du serveur.");
} catch (Exception exc) {
wrk.recevoirMessageInfo("Erreur dans la création du serveur");
}
}

```
b. Run
```
Un socket normal est utilisé pour lier le client, le socket peut être crée avec la méthode
serverSocket.accept() lorsque une requête vers le server est faite par un client, on peut
également écrire et lire sur le socket grâce aux InputStreamReader et aux OutputStreamWriter,
l’objet socket est créé sur le client et est réutilisé sur le serveur avec la méthode accept.


@Override
public void run() {
running = true;
while (running) {
try {
synchronized (serverSocket) {
Socket socketClient = serverSocket.accept();

Client client = new Client(socketClient.getInetAddress().getHostAddress(), socketClient, t
his);
clients.add(client);
client.start();
wrk.recevoirMessageInfo("Client connecté (" + socketClient.getInetAddress().getHost
Address() + ")");
attendre(10);
}
} catch (SocketTimeoutException ex) {
// rien car timeout
} catch (IOException exc) {
wrk.recevoirMessageInfo("Erreur dans la connexion d'un client.");
}
}
for (Client client : clients) {
if (client != null) {
client.setRunning(false);
try {
client.join();
client = null;
} catch (InterruptedException ex) {
}
}
}
System.gc();
wrk.recevoirMessageInfo("Serveur fermé");
}

c. Run thread
La ligne « wrkServer.removeClient(this); » permet de tuer le thread de connexion entre le
serveur et le client via TCP IP.

@Override
public void run() {
running = true;
try {
in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
while (running) {
String msg = in.readLine();
if (msg != null) {
System.out.println(msg);
wrkServer.recevoirMessageInfo(socket.getInetAddress().getHostAddress() + " : " +
msg);
wrkServer.recevoirMessage(socket.getInetAddress().getHostAddress() + " : " + msg);
} else {
running = false;
}
attendre(10);
}


wrkServer.removeClient(this);
socket.close();
} catch (IOException ex) {
}

}

3. Code important Client
    a. Connection au Serveur
Un socket est utilisé pour aller sur le server, et on utilise les « InputStreamReader » et
« OutputStreamWriter » pour écrire et recevoir des messages sur les sockets.

public boolean seConnecterAuServeur(String IP, int port) {
boolean result = false;
try {
SocketAddress sockaddr = new InetSocketAddress(InetAddress.getByName(IP),
port);
// Create your socket
socket = new Socket();
socket.connect(sockaddr, 1000);
out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
refCtrl.afficherMessage("Connexion établie");
result = true;
} catch (SocketTimeoutException ex) {
// Rien car timeout
} catch (Exception exc) {
result = false;
}
return result;
}

b. Lire Message
La ligne « readLine() » permet de lire des messages.

public String lireMessages() {
String message = null;
try {
message = in.readLine();
} catch (SocketTimeoutException ex) {
// rien à faire timeout
} catch (IOException ex) {
// Rien à faire
}
return message;
}

c. Écrire Message
La ligne « write(message + « \n ») » permet de écrire des messages.

public void ecrireMessage(String message) {
if (out != null) {
try {
out.write(message +"\n");
out.flush();
}
catch (IOException ex) {
refCtrl.afficherMessage("Erreur dans l'écriture du message.");
}
}
}

4. Réaliser un reverse du projet dans EA


Serveur :

Client :

3.2.4 Application UDP Client

a) Constructeur

Voici le contrôleur créant un nouveau DataSocket.
**public Controller() {
try {
datagramSocket = new DatagramSocket();
} catch (SocketException e) {
e.printStackTrace();
}
}**

b) **Méthode d’envoi de data**

Voici la méthode permettant de envoyer des données.
**public void send(ActionEvent actionEvent) {**


```
try {
```
```
/* Use BufferedImage as source to send over UDP
BufferedImage img = ImageIO.read(new File(txfPath.getText()));
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ImageIO.write(img, "jpg", baos);
baos.flush();
byte[] bytes = baos.toByteArray();
*/
```
```
// directly get bytes to send over UDP
byte[] bytes = Files.readAllBytes(Paths.get(txfPath.getText()));
```
```
DatagramPacket datagramPacket = new DatagramPacket(bytes,
bytes.length, InetAddress.getByName("LAPEMFB37-05"), 3945);
datagramSocket.send(datagramPacket);
} catch (IOException e) {
e.printStackTrace();
}
/* catch for solution with BufferedImage
catch (InterruptedException ex) {
Logger.getLogger(Controller.class.getName()).log(Level.SEVERE,
null, ex);
}
*/
}
```
3.2.5 Application UDP Client

a) Constructeur

Voici le contrôleur du client.
**public ServerListener(Controller c) throws SocketException {
super("Srv Listener");
socket = new DatagramSocket(3945);**

```
controller = c;
}
```
b) Méthode run

Voici la méthode permettant de recevoir des données.
**public void run() {
running = true;**

```
while (running) {
try {
```
```
DatagramPacket dp = new DatagramPacket(buf, buf.length);
socket.receive(dp);
```
```
BufferedImage i = ImageIO.read(new
ByteArrayInputStream(dp.getData()));
```
```
controller.showImage(i);
```
```
} catch (IOException e) {
e.printStackTrace();
}
}
socket.close();
}
```
#### 3.2.4 Image et vidéo (avec webcam et transport client-serveur)

```
serveur)
```

Afficher une vidéo.
Diagramme de classe :

Méthode pour afficher la vidéo :
Il est important de séparer l’audio de la vidéo.

public void afficheVideo(String filename){
String file = "videos/video.mp4";
final XuggleVideo xv = new XuggleVideo(file);
final XuggleAudio xa = new XuggleAudio(file);
VideoDisplay.createVideoDisplay(xv, xa, panelPlayer);
}

Affichage de la vidéo :


Affichage de webcam :
Diagramme de classe.


Méthodes intéressantes :
Créer webcam :
Voici la méthode permettant de créer et afficher la webcam.
private boolean createWebcam() {
boolean ok = false;
try {
//Création de la webcam avec la résolution comme paramètre
vc1 = new VideoCapture(640, 480);


vc1.setFPS(FPS);
ok = true;
} catch (VideoCaptureException ex) {
refWrk.recoitErreur("Problème lors de la création de la Webcam");
}
return ok;
}

Reconnaissance faciale :
Voici la methode permettant de reconnaitre un visage.
private void reconnaitFace() {
FaceDetector<KEDetectedFace, FImage> fd = new FKEFaceDetector();
ArrayList<KEDetectedFace> faces = (ArrayList<KEDetectedFace>)
fd.detectFaces(Transforms.calculateIntensity(frame1));
for (DetectedFace face : faces) {
Rectangle rect = face.getBounds();
rect.x -= 22.5;
rect.y -= 40;
rect.height += 50;
rect.width += 50;
face.setBounds(rect);
frame1.drawShape(face.getShape(), RGBColour.GREEN);
}
}


Capture image:
La méthode suivante permet d’effectuer une capture d’écran.
public BufferedImage captureImage() {
BufferedImage image = null;
File outputFile = new File("IMG.jpg");
try {
ImageUtilities.write(frame1, outputFile);
image = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_BINARY);
try {
image = ImageIO.read(outputFile);
} catch (IOException e) {
System.out.println("Erreur convertion fichier to BufferedImage");
}
} catch (IOException ex) {
System.out.println("Erreur Capture Image " + ex.getMessage());
}
return image;
}


3.2.7 Remarques et commentaires sur les tests de
base

Très pratique car c’est une bonne structure de base sur la quelle se posé pour commencé
l’implémentations.

### 3.3 Tests technologiques du côté client

#### 3.3.1 Manette XBOX

##### a) Explication du problème

Pour pouvoir connecter la manette au PC nous avons dû brancher une clé Bluetooth inclue au
PC. La clé Bluetooth n’avait pas le Pilote a jour et la plupart des Drivers trouvées sur internet ne
fonctionnent pas. L’application Driver Easy contient un Driver que nous avons utilisé pour faire
la mise à jour.

##### b) Source projet de tests

Le nom du projet est « ControllerXbox » et il se trouve dans le répertoire suivant :
S:\EMF\ElevesCommun\ 2021 - 2022 \giovanni.celato\306&326\TestTechnos\TTSpécifiques\PS4-
XBox\ControllerXbox

##### c) Remarques et commentaires sur le test

L’application traque tous les mouvements effectués par la manette.

d) Remarques pertinentes, à quoi il faut faire
attention, configuration spéciale etc.. une
synthèse du test technologique.

Lorsque ont appuie sur un des boutons A/B/X/Y la manette vibre et l’écran affiche le bouton
pesé :

public void buttonX(boolean pressed){
if (isStart) {
if (pressed) {
System.out.println("X");
xbone.vibrate(25000, 10000, 100);
}
}


}

Mouvement du joystick :

public void leftThumbMagnitude(double magnitude){
if (isStart) {
magnitudeGauche = magnitude;
}
}
public void leftThumbDirection(double direction){
if (isStart) {
if (direction < 270.00 && direction > 90 && magnitudeGauche > 0.2) {
System.out.println("en bas");
int vitesse =(int)(magnitudeGauche*127);

sumo.sendCommand(Pcmd.pcmd(vitesse, 0, 0));
}else if ((direction < 90.00 || direction > 270) && magnitudeGauche == 1.0){
System.out.println("en haut");
sumo.sendCommand(Pcmd.pcmd(50, 0, 0));
}
}
}

#### 3.3.2 Kinect

##### a) Explication du problème

Notre plus grande difficulté pour faire fonctionner cet Kinect ave java a été de trouvé la bonne
Library. Après plusieurs heures a essayé de débugger le projet de base qu’on nous avait fourni
mais rien ne fonctionnait. Du coup j’ai essayé de trouver d’autre exemple d’utilisation sur
internet. Après quelque essai, on a enfin trouvé une Library qui fonctionnait et c’est celle de
https://research.dwi.ufl.edu/projects/ufdw/j4k/index.php. Avec cet Library et le code d’exemple
fournit, nous pouvons recevoir le flux vidéo ainsi que tous les capteurs disponibles sur la Kinect. Ce
qui est intéressant c’est que normalement cet Library fonctionne aussi avec la nouvelle Kinect V2 ce
qui veut dire que dans le futur s’il y a besoin de passé sur du nouveau matérielle, nous avons juste a
changé la Kinect et l’adaptations se fera automatique normalement.

##### b) Source projet de tests

La Library se trouve sur le site de https://research.dwi.ufl.edu/projects/ufdw/j4k/index.php.

##### c) Remarques et commentaires sur le test

Ce qui faut faire attention lors de l’installation c’est premièrement installer les bons drivers dans
notre cas, nous avons dû installer les drivers suivants :

- SensorKinect
- Nite
- OpenNI
Après j’ai dû suivre la marche à suivre « KinectSilacciGranJean.docx ». Il faut vraiment faire
attentions à utiliser la bonne Library sinon rien ne fonctionne. Ce test technologique est très
intéressant car sa donne l’opportunité de crée beaucoup de projet en utilisant ces capteurs
disponibles sur la Kinect.


##### d) Fonctionnalité possible avec J4K

```
Récupération flux vidéo
```
```
Connecter plusieurs Kinect
```
```
Utilisation des différents capteurs
```

##### e) Récupérer flux vidéo

VideoPanel main_panel;

Kinect myKinect;
myKinect=new Kinect();

// Démarre le streaming en mode vidéo de couleur
myKinect.start(J4KSDK.COLOR)

// Relie le flux vidéo à la page d'affichage
main_panel=new VideoPanel();
myKinect.setViewer(main_panel);

### 3.4 Tests technologiques du côté serveur

#### 3.4.1 7Links

##### a) Explication du problème

Le robot ne s’affichait pas dans les paramètres WIFI.
Pour résoudre ce problème nous avions dû rester appuyer sur le bouton « Reset » jusqu’à ce
que le robot pointe la caméra vers le haut. Le bouton se trouve sur le bas du robot.

##### b) Source projet de tests

Le nom du projet est « API_Robot7Links_Test » et il se trouve dans le répertoire suivant :
S:\EMF\ElevesCommun\ 2021 -
2022 \giovanni.celato\306&326\TestTechnos\TTSpécifiques\7links\API_Robot7Links_Test

##### c) Remarques et commentaires sur le test


Pour débuter il faut se connecter au robot à travers le WIFI.

Lorsqu’on lance l’application il faut cliquer sur « Initialiser un robot ».


Le nom du robot sera affiché si on est connecté au réseau du robot, lorsqu’on clique sur
« Initialiser », puis il est possible de connecter le robot a un réseau en scannant les réseaux et
sélectionnant le réseau souhaité.

Après avoir connecté le robot a un réseau on doit se déconnecter du robot et se connecter au
même réseau que le robot.


Finalement on doit noter l’adresse IP qui a été attribué au robot pour pouvoir le piloter.

d) Remarques pertinentes, à quoi il faut faire
attention, configuration spéciale etc.. une
synthèse du test technologique.

Connection au Wifi :
La methode suivante permet de ce connecter au réseau WIFI, on utilise une méthode lorsque on
reçoit l’information de la sélection d’un wifi, puis une autre qui lance une connexion au robot, le
robot répond vocalement si la connexion est bien établie ou s’il y a eu une erreur.
@FXML
private void connect(ActionEvent event) {
Wifi w = lstWifi.getSelectionModel().getSelectedItem();
if (w != null) {
wifi = w;
if (!wifi.getSecurityType().equals(Wifi.SecurityType.OPEN)) {
Fenetre f =
WindowManager.creerFenetre("/api_robot7links_test/view/PasswordView.fxml", "Mot de
passe");
PasswordViewController ctrl = (PasswordViewController) f.getCtrl();
ctrl.setRefCtrl(this);
f.show();
} else {
onPasswordReceived("");
}
}
}

Connexion au Robot :
On peut connecter le robot, la connexion au robot se fait grâce à son adresse IP, son ID et le
mot de passe.


private void connect() {
loader.setVisible(true);
Thread t = new Thread() {
@Override
public void run() {
try {
String ip = getIP();
if (ip != null) {
robot.connect(ip, myRobot.getId(), myRobot.getPw());
if (!robot.isConnected()) {
WindowManager.afficherErreur(robot.getLastError());
}
}
} catch (UnreachableRobotException ex) {
WindowManager.afficherErreur(ex.getMessage());
} finally {
Platform.runLater(() -> {
loader.setVisible(false);
});
}
}
};
t.start();
}

La méthode suivante permet de récupérer l’adresse IP noté par l’utilisateur.

private String getIP() {
String ip = null;
String b1 = txtIp1.getText();
String b2 = txtIp2.getText();
String b3 = txtIp3.getText();
String b4 = txtIp4.getText();
if (b1.isEmpty() | b2.isEmpty() | b3.isEmpty() | b4.isEmpty()) {
WindowManager.afficherAlerte("L'adresse ip n'est pas complète.");
} else {
try {
Integer.parseInt(b1);
Integer.parseInt(b2);
Integer.parseInt(b3);
Integer.parseInt(b4);
ip = b1 + "." + b2 + "." + b3 + "." + b4;
} catch (NumberFormatException ex) {
WindowManager.afficherAlerte("L'adresse ip n'est pas valide.");
}
}
return ip;
}

Méthodes de mouvement du robot en fonction de la manette Xbox :

@FXML
private void neutre(ActionEvent event) {
robot.setRightSpeed((short) 0);
robot.setLeftSpeed((short) 0);
}

@FXML
private void gauche(ActionEvent event) {
robot.setRightSpeed((short) 600);
robot.setLeftSpeed((short) 200);
}

@FXML


private void droite(ActionEvent event) {
robot.setRightSpeed((short) 200);
robot.setLeftSpeed((short) 600);
}

@FXML
private void avant(ActionEvent event) {
robot.setRightSpeed((short) 999);
robot.setLeftSpeed((short) 999);
}

@FXML
private void arriere(ActionEvent event) {
robot.setRightSpeed((short) -600);
robot.setLeftSpeed((short) -600);
}

Méthodes de mouvement de tête :
Les méthodes suivantes sont les mouvements de la tête du robot, chaque méthode est
responsable pour une Activité différente.

- Monter la tête
- Tête neutre
- Baisser la tête
@FXML
private void headUp(ActionEvent event) {
robot.setHeadDirection(RobotState.HeadDirection.UP);
}

@FXML
private void headNeutre(ActionEvent event) {
robot.setHeadDirection(RobotState.HeadDirection.NONE);
}

@FXML
private void headDown(ActionEvent event) {
robot.setHeadDirection(RobotState.HeadDirection.DOWN);
}

Allumer les LED:
Voici les méthodes permettant d’allumer les LED du robot.
public void setLedEnabled(boolean enabled) {
robotState.setLedEnabled(enabled);
if (wrkUDP != null) {
wrkUDP.setRobotState(robotState);
}
}

private void led(ActionEvent event) {
robot.setLedEnabled(!robot.getRobotState().isLedEnabled());
}

### 3.5 Conclusion sur les tests technologiques

Mise à part les problèmes qu’on a eus avec la Kinect, on a pu apprendre beaucoup de
nouveauté sur le fonctionnement des threads.

## 4 Spécificités matérielles........................................................................................................

### Matériel Annexe


```
Webcam (N’importe quel version)
```
```
Manette Xbox One avec clé
(Nécessite un driver disponible sur internet)
```
```
Robot 7links version 1
```
## 5 Spécificités logicielles

Les librairies utilisées sont celle qui se trouve dans les tests spécifiques :

- Test spécifique manette Xbox, ainsi que driver disponible sur internet.
- Test spécifique webcam
- Test spécifique 7links
Tous ces tests spécifiques se trouvent sur le commun.

## 6 Conception

### 6.1 Introduction

Avant de partir dans l’implémentation de l’application, nous avons dû réfléchir à comment les
applications vont être structurer. Pour ce faire, nous avons pour les deux applications fait des
schémas de classe qui montrent comment l’application est structuré.

#### 6.1.1 Thread

Chaque thread définit un chemin d'exécution distinct. Lorsqu'un programme Java démarre, un
thread commence immédiatement à s'exécuter. On l'appelle généralement le thread principal de
notre programme, car c'est celui qui est exécuté au début du programme.

#### 6.1.2 Interface.............................................................................................................

Une interface en Java est une ébauche d'une classe. Elle possède des constantes statiques et
des méthodes abstraites. L'interface en Java est un mécanisme permettant de réaliser
l'abstraction. Il ne peut y avoir que des méthodes abstraites dans l'interface Java, pas de corps
de méthode. Elle est utilisée pour réaliser l'abstraction et l'héritage multiple en Java.

### 6.2 Application client


#### 6.2.1 Diagramme de classes MVC2 de l’application

Le diagramme suivant est le diagramme MVC2 contenant en jaune les classes principales de
l’IHM, en vert celles du contrôleur puis en bleu les classes principales du worker. Le worker
contiens des classes non-cités dans le diagramme MVC2 et développées dans le point « 6. 2 .3
Diagramme de classes Wrk ».

#### 6.2.2 Diagramme de classes Ihm

L’application client possède un contrôleur IHM avec une interface contenant les méthodes
abstraites.

```
class app
```
```
Ctrl::ItfCtrl
+ + displayError(String): voiddisplayVideo(byte[]): void
```
```
Wrk::ItfWrk
+ + faceIDLogin(Image): booleanfaceIDRegister(Image): boolean
+ + kinectIsConnected(): booleanrobotConnect(): boolean
+ + robotDirection(String): voidrobotDisconnect(): boolean
+ + stopT hreads(): voiduserLogin(String, String): void
+ + userLogout(): voiduserRegister(String, String, String): void
+ xboxControlerIsConnected(): boolean
```
```
Wrk::Wrk
```
- refCtrl: ItfCtrl

```
Danilo Anzile - G224.11.2021
Version 2Konnect - Client
```
```
Ctrl::Ctrl
```
- refWrk: ItfWrk
+ + displayError(String): voiddisplayVideo(byte[]): void
+ + faceIDLogin(Image): booleanfaceIDRegister(Image): boolean
+ + kinectIsConnected(): booleanrobotConnect(): boolean
+ + robotDirection(): voidrobotDisconnect(): boolean
+ + saveScreenshot(): voidstopT hreads(): void
+ + takeScreenshoot(): voiduserLogin(String, String): void
+ + userLogout(): voiduserRegister(): void
+ xboxControlerIsConnected(): boolean
Ihm::View Ctrl
- refCtrl: ItfCtrl
+ + afficheErreur(String): voidafficheFrame(BufferedImage): void
+ + initialize(): voidlireMessage(): String
+ stopWebcam(): void

```
Ihm::ItfView Ctrl«interface»
+ + afficheErreur(String): voidafficheFrame(BufferedImage): void
+ + lireMessage(): StringshowRobotImg(WritableImage): void
+ stopWebcam(): void
```
```
-refCtrl
```
```
-refIhm -refWrk
```
```
-refCtrl
```

#### 6.2.3 Diagramme de classes Wrk

Chaque acteur (Web Cam, Controlleur Xbox...) contient son propre worker, tous les workers
sont regroupées dans un worker principal nommée « Wrk ».

#### 6.2.4 Diagramme de classes Beans

Pour le côté client n’a pas de beans.

```
class Ihm
```
```
View Ctrl
```
- refCtrl: ItfCtrl
+ afficheErreur(String): void
+ afficheFrame(BufferedImage): void
+ initialize(): void
+ lireMessage(): String
+ stopWebcam(): void

```
«interface»
ItfView Ctrl
+ afficheErreur(String): void
+ afficheFrame(BufferedImage): void
+ lireMessage(): String
+ showRobotImg(WritableImage): void
+ stopWebcam(): void
```
```
Danilo Anzile - G2
24.11.2021
Version 2
Konnect - Client
```
```
class Wrk
```
```
Danilo Anzile - G201.12.2021
Konnect - ClientVersion 4
```
```
Wrk
```
- - refClientT CPWrk: ClientT CPWrkrefClientUDPWrk: ClientUDPWrk
- - refMyWebCam: MyWebCamrefXboxControlerWrk: XboxControlerWrk

```
XboxControlerWrkXbox Controller
```
- refWrk: ItfWrkXboxControler
+ + buttonA(boolean): voidbuttonB(boolean): void
+ + connecterManette(): doubledisconnect(): boolean
+ + leftT rigger(boolean): voidrightT igger(boolean): void

```
MyWebCamThread
```
- refWrk: ItfWrkMyWebCam
+ run(): void

```
ClientTCPWrk Thread
```
- refWrk: ItfWrkClientT CP
+ + connectT oServer(String, int): voidrun(): void
+ sendDirection(): void

```
ItfWrkMyWebCam«interface»
+ recoitFrame(BufferedImage): void «interface»ItfWrkCtrl
+ + faceIDLogin(Image): booleanfaceIDRegister(Image): boolean
+ + robotConnect(): booleanrobotDirection(String): void
+ + robotDisconnect(): booleanstopT hreads(): void
+ + userLogin(String, String): voiduserLogout(): void
+ + userRegister(String, String, String): voidxboxControlerIsConnected(): boolean
```
```
ItfWrkClientTCP«interface»
+ showRobotImg(WritableImage): void
```
```
ItfWrkXboxControler«interface»
+ robotDirection(String): void
```
```
ClientUDPWrk
```
- refWrk: ItfWrkClientT CP

```
ItfWrkClientUDP«interface»
```
```
-refWrk
```
```
-refWrk ̈-refClientUDPWrk
```
```
-refClientT CPWrk
```
```
-refXboxControlerWrk
```
```
-refWrk
```
```
-refKinectWrk
```
```
-refWrk
```

### 6.3 Application serveur

#### 6.3.1 Diagramme de classes MVC2 de l’application

Le diagramme suivant est le diagramme MVC2 contenant en jaune les classes principales de
l’IHM, en vert celles du contrôleur puis en bleu les classes principales du worker. Le worker
contiens des classes non-cités dans le diagramme MVC2 et développées dans le point « 6.3.3
Diagramme de classes Wrk ».

#### 6.3.2 Diagramme de classes Ihm

Chaque « .fxml » a son propre contrôleur. Pour le serveur possède 2 vues et donc deux
contrôleurs. Un contrôleur de vue géré tous les contrôleurs des ihm.

```
class app
App Application
```
- - refCtrl: CtrlrefViewCtrl: ViewCtrl
- - refWrk: Wrkmain(String[]): void
+ start(Stage): void
- refIhm: CtrlIhmItf **ctrl::Ctrl**
- + refWrk: WrkCtrlItfaddUser(String, String, boolean): void
+ + afficheVideo(byte[]): voidconnecterDB(): void
+ + connecterRobot(): voidconnectUser(String, String): boolean
+ + connexionRobotTermine(boolean): voiddeconnecterDB(): void
+ + deconnecterRobot(): voiddeleteUser(User): void
+ + disconnectUser(): voideditUser(User): void
+ + initialiserRobot(): voidsetRefIhm(CtrlIhmItf): void
+ + setRefWrk(WrkCtrlItf): voidstartServer(int): void
- mainStage: Stage **ctrl::ViewCtrl**
- - refCrtl: CtrlItfrefMainCtrl: MainCtrl
- - refSecondCtrl: SecondCtrlsecondStage: Stage
+ + addUser(String, String, boolean): voidconnectRobot(): void
+ + connectUser(String, String): booleanconnexionRobotTermine(boolean): void
+ + deconnecterDB(): voiddeconnecterRobot(): void
+ + deconnecterUser(): voiddeleteUser(User): void
+ + editUser(User): voidinitialiseRobot(): void
+ + initialize(): voidloadMainCtrl(): MainCtrl
+ + loadSecondView(): SecondCtrlonImageReceived(byte[]): void
+ + quitter(): voidsetRefCrtl(CtrlItf): void
+ + setRefMainCtrl(MainCtrl): voidshowfirstView(): void
+ + showSecondView(): voidViewCtrl(Stage)

```
ctrl::CtrlIhmItf «interface»
+ + connexionRobotTermine(boolean): voidonImageReceived(byte[]): void
```
```
«interface» ctrl::CtrlItf
+ + addUser(String, String, boolean): voidafficheVideo(byte[]): void
+ + connecterDB(): voidconnecterRobot(): void
+ + connectUser(String, String): booleanconnexionRobotTermine(boolean): void
+ + deconnecterDB(): voiddeconnecterRobot(): void
+ + deleteUser(User): voiddisconnectUser(): void
+ + editUser(User): voidinitialiserRobot(): void
```
```
ctrl::ViewCtrlItf «interface»
+ + addUser(String, String, boolean): voidconnectRobot(): void
+ + connectUser(String, String): booleanconnexionRobotTermine(boolean): void
+ + deconnecterDB(): voiddeconnecterRobot(): void
+ + deconnecterUser(): voiddeleteUser(User): void
+ + editUser(User): voidinitialiseRobot(): void
+ + loadMainCtrl(): MainCtrlloadSecondView(): SecondCtrl
+ + onImageReceived(byte[]): voidquitter(): void
+ + setRefCrtl(CtrlItf): voidsetRefMainCtrl(MainCtrl): void
+ + showfirstView(): voidshowSecondView(): void
```
- bPane: BorderPane **ihm::MainCtrl**
- - btnLogin: ButtonbtnQuit: Button
- - refViewCtrl: ViewCtrlItftxfPassword: TextField
- - txfUsername: TextFieldactionSecondStage(ActionEvent): void
+ + initialize(): voidquitter(): void
+ setRefCtrl(ViewCtrl): void

```
ihm::SecondCtrl Initializable
```
- - bPane: BorderPanebtnAddUser: Button
- - btnConnectDB: ButtonbtnConnectRobot: Button
- - btnDeleteUser: ButtonbtnDisconnectDB: Button
- - btnDisconnectRobot: ButtonbtnEditUser: Button
- - btnInitialisationRobot: ButtonimvRobot: ImageView
- - mainStage: ViewCtrlItfrdbAdmin: RadioButton
- - txfPassword: TextFieldtxfUsername: TextField
- - actionRetour(ActionEvent): voidaddUser(ActionEvent): void
+ - afficheVideo(byte[]): voidconnecterDatabase(ActionEvent): void
- + connecterRobot(ActionEvent): voidconnexionRobotTermine(boolean): void
- - deconnecterDatabase(ActionEvent): voiddeconnecterRobot(ActionEvent): void
- - deleteUser(ActionEvent): voideditUser(ActionEvent): void
- + initialiserRobot(ActionEvent): voidinitialize(URL, ResourceBundle): void
+ + quitter(): voidsetMainStage(ViewCtrl): void

```
+ PU: String = "DoubleStage_FXMLPU" {readOnly} wrk::Wrk
```
- - refclient: ClientrefCtrl: CtrlItf
- - refRobot: Wrk7LinksrefSerialisation: WrkSerialisation
- - refTCP: WrkServerTcprefUDP: WrkServerUDP
- - refWrkDB: WrkDbItfserverSocket: volatile ServerSocket
+ + addUser(String, String, boolean): voidconnecterDB(): void
+ + connectRobot(): voidconnectUser(String, String): boolean
+ + connexionRobotTermine(boolean): voiddeconnecterDB(): void
+ + deconnecterRobot(): voiddeconnecterUser(): void
+ + deleteUser(User): voiddeserialiserRobot(): Object
+ + editUser(User): voidenvoieImage(byte[]): void
+ + filtreLoginUser(String): voidgetimage(byte[]): void
+ + getMessage(String): voidinitialisationRobot(): void
- + isAdmin(String, String): shortmouvementRobot(String): void
+ + serialiserRobot(Object): ObjectsetRefCtrl(CtrlItf): void
+ + startServer(int): voidstopServer(): void
+ Wrk()

```
wrk::WrkCtrlItf «interface»
+ + addUser(String, String, boolean): voidconnecterDB(): void
+ + connectRobot(): voidconnectUser(String, String): boolean
+ + deconnecterDB(): voiddeconnecterRobot(): void
+ + deconnecterUser(): voiddeleteUser(User): void
+ + editUser(User): voidenvoieImage(byte[]): void
+ + initialisationRobot(): voidstartServer(int): void
+ stopServer(): void
```
```
G02-300231Konnect
Application serveurJoel Neuhaus
22.11.2021Version 4.0
```
```
-refIhm
```
```
-refWrk
```
```
-refCrtl
```
```
-refViewCtrl
```
```
-refSecondCtrl
```
```
-refViewCtrl -refCtrl
```
```
-refCtrl
```
```
-refMainCtrl
```
```
-mainStage
```
```
-refWrk
```

#### 6.3.3 Diagramme de classes Wrk

Chaque acteur (Base de données, Robot...) contient son propre worker, tous les workers sont
regroupées dans un worker principal nommée « Wrk ».

```
class ihm
```
```
MainCtrl
```
- bPane: BorderPane
- btnLogin: Button
- btnQuit: Button
- refViewCtrl: ViewCtrlItf
- txfPassword: TextField
- txfUsername: TextField
- actionSecondStage(ActionEvent): void
+ initialize(): void
+ quitter(): void
+ setRefCtrl(ViewCtrl): void

```
Initializable
SecondCtrl
```
- bPane: BorderPane
- btnAddUser: Button
- btnConnectDB: Button
- btnConnectRobot: Button
- btnDeleteUser: Button
- btnDisconnectDB: Button
- btnDisconnectRobot: Button
- btnEditUser: Button
- btnInitialisationRobot: Button
- imvRobot: ImageView
- mainStage: ViewCtrlItf
- rdbAdmin: RadioButton
- txfPassword: TextField
- txfUsername: TextField
- actionRetour(ActionEvent): void
- addUser(ActionEvent): void
+ afficheVideo(byte[]): void
- connecterDatabase(ActionEvent): void
- connecterRobot(ActionEvent): void
+ connexionRobotTermine(boolean): void
- deconnecterDatabase(ActionEvent): void
- deconnecterRobot(ActionEvent): void
- deleteUser(ActionEvent): void
- editUser(ActionEvent): void
- initialiserRobot(ActionEvent): void
+ initialize(URL, ResourceBundle): void
+ quitter(): void
+ setMainStage(ViewCtrl): void

```
«interface»
ctrl::ViewCtrlItf
+ addUser(String, String, boolean): void
+ connectRobot(): void
+ connectUser(String, String): boolean
+ connexionRobotTermine(boolean): void
+ deconnecterDB(): void
+ deconnecterRobot(): void
+ deconnecterUser(): void
+ deleteUser(User): void
+ editUser(User): void
+ initialiseRobot(): void
+ loadMainCtrl(): MainCtrl
+ loadSecondView(): SecondCtrl
+ onImageReceived(byte[]): void
+ quitter(): void
+ setRefCrtl(CtrlItf): void
+ setRefMainCtrl(MainCtrl): void
+ showfirstView(): void
+ showSecondView(): void
```
```
ctrl::ViewCtrl
```
- mainStage: Stage
- refCrtl: CtrlItf
- refMainCtrl: MainCtrl
- refSecondCtrl: SecondCtrl
- secondStage: Stage
+ addUser(String, String, boolean): void
+ connectRobot(): void
+ connectUser(String, String): boolean
+ connexionRobotTermine(boolean): void
+ deconnecterDB(): void
+ deconnecterRobot(): void
+ deconnecterUser(): void
+ deleteUser(User): void
+ editUser(User): void
+ initialiseRobot(): void
+ initialize(): void
+ loadMainCtrl(): MainCtrl
+ loadSecondView(): SecondCtrl
+ onImageReceived(byte[]): void
+ quitter(): void
+ setRefCrtl(CtrlItf): void
+ setRefMainCtrl(MainCtrl): void
+ showfirstView(): void
+ showSecondView(): void
+ ViewCtrl(Stage)

```
G02-300231
Konnect
Application serveur
Joel Neuhaus
22.11.2021
Version 4.0
```
```
-refSecondCtrl
```
```
-refMainCtrl
```
```
-refViewCtrl -mainStage
```

#### 6.3.4 Diagramme de classes Beans

Du coté serveur il y a trois beans différents.
Le beans « MyRobot » est liée au robot.
Les beans « Photo » et « User » sont des beans venant de la base de données contentant les
utilisateurs ayant accès à l’application.

```
class wrk
```
```
Wrk
+ - PU: String = "DoubleStage_FXMLPU" {readOnly}refclient: Client
```
- - refCtrl: CtrlItfrefRobot: Wrk7Links
- - refSerialisation: WrkSerialisationrefTCP: WrkServerTcp
- - refUDP: WrkServerUDPrefWrkDB: WrkDbItf
- serverSocket: volatile ServerSocket
+ + addUser(String, String, boolean): voidconnecterDB(): void
+ + connectRobot(): voidconnectUser(String, String): boolean
+ + connexionRobotTermine(boolean): voiddeconnecterDB(): void
+ + deconnecterRobot(): voiddeconnecterUser(): void
+ + deleteUser(User): voiddeserialiserRobot(): Object
+ + editUser(User): voidenvoieImage(byte[]): void
+ + filtreLoginUser(String): voidgetimage(byte[]): void
+ + getMessage(String): voidinitialisationRobot(): void
- + isAdmin(String, String): shortmouvementRobot(String): void
+ + serialiserRobot(Object): ObjectsetRefCtrl(CtrlItf): void
+ + startServer(int): voidstopServer(): void
+ Wrk()

```
«interface» WrkCtrlItf
+ + addUser(String, String, boolean): voidconnecterDB(): void
+ + connectRobot(): voidconnectUser(String, String): boolean
+ + deconnecterDB(): voiddeconnecterRobot(): void
+ + deconnecterUser(): voiddeleteUser(User): void
+ + editUser(User): voidenvoieImage(byte[]): void
+ + initialisationRobot(): voidstartServer(int): void
+ stopServer(): void
```
```
EPK
dao::JpaDao
```
- - cl: Class<E> {readOnly}em: EntityManager
- - emf: EntityManagerFactoryet: EntityTransaction
+ + compter(): longcreer(E): void
+ + deconnecter(): voideffacer(PK): void
+ + effacerListe(): intestConnectee(): boolean
+ + filtrer(String, Object): List<E>JpaDao(String, Class<E>)
+ + lire(PK): ElireListe(): List<E>
+ + lireListe(String): List<E>modifier(E): void
+ + rechercher(String, Object): EsauverListe(List<E>): int

```
«interface»
```
```
EPK
dao::JpaDaoItf
+ + compter(): longcreer(E): void
+ + deconnecter(): voideffacer(PK): void
+ + effacerListe(): intestConnectee(): boolean
+ + filtrer(String, Object): List<E>lire(PK): E
+ + lireListe(String): List<E>lireListe(): List<E>
+ + modifier(E): voidrechercher(String, Object): E
+ sauverListe(List<E>): int
```
```
db::WrkDb
```
- - JPA_PU: String = "KonnectPU" {readOnly}photosWrk: JpaDaoItf<Photo, Integer>
- userWrk: JpaDaoItf<User, Integer>
+ + connecterUser(String, String): booleanconnexionBD(): void
+ + creerUser(String, String, boolean): voiddeconnexionDB(): void
+ + deconnexionUser(): voidisAdmin(String): short
+ + modifierUser(User): voidsupprimerUser(User): void **db::WrkDbItf** «interface»
    + + connecterUser(String, String): booleanconnexionBD(): void
    + + creerUser(String, String, boolean): voiddeconnexionDB(): void
    + + deconnexionUser(): voidisAdmin(String): short
    + + modifierUser(User): voidsupprimerUser(User): void

```
robot::Wrk7Links Thread
```
- - id: intip: String
- - lastConnected: booleanmyRobot: MyRobot {readOnly}
- - pw: intrefWrk: Wrk7LinksItf
- - robot: Robot {readOnly}running: boolean
- - arriere(): voidattend(int): void
- + avant(): voidconnexion(): boolean
+ - disconnect(): voiddroite(): void
- + gauche(): voidgetimage(byte[]): Image
+ - mouvementRobot(String): voidneutre(): void
+ + premiereInitialisation(): voidrun(): void
+ + standUp(): voidWrk7Links(Wrk)

```
robot::Wrk7LinksItf «interface»
+ + connexionRobotTermine(boolean): voiddeserialiserRobot(): Object
+ + getimage(byte[]): voidmouvementRobot(String): void
+ serialiserRobot(Object): Object
```
```
serialisation::WrkSerialisation
+ + deserialiseObjet(String): ObjectserialiseObjet(String, Object): boolean
+ WrkSerialisation()
```
```
tcp::Client Thread
```
- - in: BufferedReadermouvement: String
- - out: BufferedWriterrunning: boolean
- - socket: SocketwrkServer: volatile ClientServerTcpItf
+ + attendre(long): voidClient(String, Socket, WrkServerTcp)
+ + getIPClient(): InetAddressisRunning(): boolean
+ + quitter(): voidrun(): void
+ + sendData(String): voidsetRunning(boolean): void

```
tcp::WrkServerTcp Thread
```
- - clients: volatile ArrayList<Client>refClient: Client
- - refWrkServerTcp: WrkServerTcpItfrunning: volatile boolean
- serverSocket: volatile ServerSocket
+ + attendre(long): voidfiltreLoginUser(String): void
+ + getIPClient(): InetAddressgetMessage(String): void
+ + getRefClient(): ClientmouvementRobot(String): void
+ + removeClient(Client): voidrun(): void
+ + startServer(int): voidstopServer(): void
+ WrkServerTcp(Wrk)

```
tcp::ClientServerTcpItf «interface»
+ + filtreLoginUser(String): voidgetIPClient(): InetAddress
+ + getMessage(String): voidmouvementRobot(String): void
+ removeClient(Client): void
```
```
tcp::WrkServerTcpItf «interface»
+ + filtreLoginUser(String): voidgetMessage(String): void
+ mouvementRobot(String): void
```
```
udp::WrkServerUDP Thread
```
- ds: DatagramSocket
+ + envoieImage(byte[], InetAddress): voidfinalize(): void
- + resizeImage(BufferedImage, int, int): BufferedImageWrkServerUDP()

```
G02-300231Konnect
Application serveurJoel Neuhaus
22.11.2021Version 4.0
```
```
-refclient -refWrk
```
```
< E->User, PK->Integer >
```
```
-userWrk
```
```
-refRobot
```
```
-refWrkServerTcp
```
```
-refWrkDB -refUDP
```
```
-refClient
```
```
-refSerialisation
```
```
< E->Photo, PK->Integer >
```
```
-photosWrk
```
```
< E->E, PK->PK >
```
```
-wrkServer
```
```
-refTCP
```

### 6.4 Modèle de la base de données

### 6.5 Conclusion

Plusieurs versions de la conception ont été faites car il est difficile de prédire toutes les
méthodes et classes nécessaires pour la conception. Mais après pas mal d’essaye, nous
sommes arrivés à un résultat qui fonctionne.

## 7 Implémentation

### 7.1 Reverse engineering client

#### 7.1.1 Diagramme de classes MVC2 (client)

Le diagramme suivant est le diagramme MVC2 contenant en jaune les classes principales de
l’IHM, en vert celles du contrôleur puis en bleu les classes principales du worker. Le worker
contiens des classes non-cités dans le diagramme MVC2 et développées dans le point « 7.1.3 »
Diagramme de classes Wrk ».

```
class beans
```
```
Serializable
MyRobot
```
- hostname: String
- id: int
- ip: String
- pw: int
+ getHostname(): String
+ getId(): int
+ getIp(): String
+ getPw(): int
+ MyRobot(String, String, int, int)
+ MyRobot()
+ MyRobot(int, int, String)
+ setHostname(String): void
+ setId(int): void
+ setIp(String): void
+ setPw(int): void
+ toString(): String

```
Photo User Serializable
```
- admin: short
- password: String
- pKuser: Integer
- serialVersionUID: long = 1L {readOnly}
- username: String
+ equals(Object): boolean
+ getAdmin(): short
+ getPassword(): String
+ getPKuser(): Integer
+ getUsername(): String
+ hashCode(): int
+ setAdmin(short): void
+ setPassword(String): void
+ setPKuser(Integer): void
+ setUsername(String): void
+ toString(): String
+ User()
+ User(Integer)
+ User(Integer, String, String, short)

```
Author: Joel Neuhaus
Groupe: G2_300231
Module: 306&326
Version: 2.0
Date: 22.11.2021
```

#### 7.1.2 Diagramme de classes Ihm (client)

Chaque IHM possède son propre contrôleur et sa propre interface. En total il y a donc 8
contrôleurs de 8 IHM différents. Le contrôleur nommé « ViewCtrl » regroupe tous les
contrôleurs des IHM.

```
class app
AppApplication
```
- - refCtrl: CtrlrefViewCtrl: ViewCtrl
- + refWrk: Wrkmain(String[]): void
+ start(Stage): void
- refIhm: ItfViewCtrlCtrl::Ctrl
- + refWrk: ItfWrkCtrlcheckUser(String, String): String
+ + disconnect(): voiddisplayError(String): void
+ + faceIDLogin(): StringisControlerConnect(): String
+ + lireMessage(): StringrecoitFrame(BufferedImage): void
+ + registerUser(String, String): booleansetRefIhm(ItfViewCtrl): void
+ + setRefWrk(ItfWrkCtrl): voidshowRobotImg(WritableImage): void
+ + startWebcam(): voidstopWebcam(): void
+ + takeScreenshot(): voidtakeScreenshotFromControler(WritableImage): void
+ + userLogout(): voidxboxControlerIsConnected(): boolean

```
«interface»Ctrl::ItfCtrl
+ + checkUser(String, String): Stringdisconnect(): void
+ + displayError(String): voidfaceIDLogin(): String
+ + isControlerConnect(): StringlireMessage(): String
+ + recoitFrame(BufferedImage): voidregisterUser(String, String): boolean
+ + showRobotImg(WritableImage): voidstartWebcam(): void
+ + stopWebcam(): voidtakeScreenshot(): void
+ takeScreenshotFromControler(WritableImage): void
```
- adminView: StageIhm::View Ctrl
- - clientView: StageconfigFaceIDView: Stage
- - faceIDView: StagekonnectView: Stage
- - loginView: StagerefCtrl: ItfCtrl
- - refCtrlAdmin: ItfAdminCtrlrefCtrlClient: ItfClientCtrl
- - refCtrlConfigFaceID: ItfConfigFaceIDCtrlrefCtrlFaceID: ItfFaceIDCtrl
- - refCtrlKonnect: ItfKonnectCtrlrefCtrlLogin: ItfLoginCtrl
- - refCtrlRegister: ItfRegisterCtrlrefCtrlScreenshot: ItfScreenshotCtrl
- - registerView: StagescreenshotView: Stage
+ + afficheErreur(String): voidafficheFrame(BufferedImage): void
+ + checkUser(String, String): StringconnectionFaceID(): String
+ + disconnect(): voidgetRefCtrl(): ItfCtrl
+ + initialize(): voidisControlerConnect(): String
+ - lireMessage(): StringloadAdminView(): AdminCtrl
- - loadClientView(): ClientCtrlloadConfigFaceIDView(): ConfigFaceIDCtrl
- - loadFaceIDView(): FaceIDCtrlloadKonnectView(): KonnectCtrl
- - loadLoginView(): LoginCtrlloadRegisterView(): RegisterCtrl
- + loadScreenshotView(): ScreenshotCtrlregisterUser(String, String): boolean
+ + screenshot(WritableImage): voidsetRefCtrl(ItfCtrl): void
+ + showAdminView(): voidshowClientView(): void
+ + showConfigFaceIDView(): voidshowFaceIDView(): void
+ + showKonnectView(): voidshowLoginView(): void
+ + showRegisterView(): voidshowRobotImg(WritableImage): void
+ + showScreenshotView(): voidstartWebcam(): void
+ + stopWebcam(): voidtakeScreenshot(): void
+ ViewCtrl(Stage)

```
Ihm::ItfView Ctrl«interface»
+ + afficheErreur(String): voidafficheFrame(BufferedImage): void
+ + checkUser(String, String): StringconnectionFaceID(): String
+ + disconnect(): voidgetRefCtrl(): ItfCtrl
+ + isControlerConnect(): StringlireMessage(): String
+ + registerUser(String, String): booleanscreenshot(WritableImage): void
+ + showAdminView(): voidshowClientView(): void
+ + showConfigFaceIDView(): voidshowFaceIDView(): void
+ + showKonnectView(): voidshowLoginView(): void
+ + showRegisterView(): voidshowRobotImg(WritableImage): void
+ + showScreenshotView(): voidstartWebcam(): void
+ + stopWebcam(): voidtakeScreenshot(): void
```
```
+ HEIGHT : int = 480 {readOnly}Wrk::Wrk
```
- - refClientT CPWrk: ClientT CPWrkrefClientUDPWrk: ClientUDPWrk
- - refCtrl: ItfCtrlrefXboxControlerWrk: XboxControlerWrk
- - userConnected: booleanwebcam: MyWebCam
+ WIDT H: int = 640 {readOnly}
+ + checkUser(String, String): Stringdisconnect(): void
+ + initialiser(): voidisControlerConnect(): String
+ + lireMessage(): StringrecoitErreur(String): void
+ + recoitFrame(BufferedImage): voidregisterUser(String, String): boolean
+ + robotDirection(String): voidsetRefClientT CPWrk(ClientT CPWrk): void
+ + setRefCtrl(ItfCtrl): voidsetRefXboxControlerWrk(XboxControlerWrk): void
+ + showRobotImg(WritableImage): voidstartWebcam(): boolean
+ + stopWebcam(): booleantakeScreenshot(): void
+ + userLogout(): voidutilisateurT rouver(): String
+ + Wrk()xboxControlerIsConnected(): boolean

```
Wrk::ItfWrkCtrl«interface»
+ + checkUser(String, String): Stringdisconnect(): void
+ + isControlerConnect(): StringlireMessage(): String
+ + registerUser(String, String): booleanrobotDirection(String): void
+ + startWebcam(): booleanstopWebcam(): boolean
+ + takeScreenshot(): voiduserLogout(): void
+ + utilisateurT rouver(): StringxboxControlerIsConnected(): boolean
```
```
Danilo Anzile - G224.11.2021
Version 2Konnect - Client
```
```
-refCtrl
```
```
-refCtrl
```
```
-refIhm +refWrk
```
```
-refViewCtrl
```
```
-refCtrl
```
```
+refWrk
```
```
class Ihm
```
- - bPane: BorderPanebtn_logout: ButtonAdminCtrl
- - - btn_takePicture: Buttonimgv_robot: ImageViewlbl_controlerConnected: Label
~ - + refViewCtrl: ItfViewCtrllogout(ActionEvent): voidquitter(): void
- + + refresh(ActionEvent): voidrefreshPeripherique(): voidsetRefViewCtrl(ItfViewCtrl): void
+ - showRobotImg(WritableImage): voidtakePicture(ActionEvent): void
    - - bPane: BorderPanebtn_logout: ButtonClientCtrl
    - - ~ imgv_robot: ImageViewlbl_controlerConnected: LabelrefViewCtrl: ItfViewCtrl
    + - + actualiserPeripherique(): voidlogout(ActionEvent): voidquitter(): void
    + + + refresh(ActionEvent): voidsetRefViewCtrl(ItfViewCtrl): voidshowRobotImg(WritableImage): void
       - - bPane: BorderPanebtn_backRegisterPage: ButtonConfigFaceIDCtrl
       - - ~ btn_takePictureFaceID: ButtonImgvWebCam: ImageViewrefViewCtrl: ItfViewCtrl
       + - + afficheFrame(BufferedImage): voidbackRegisterPage(ActionEvent): voidquitter(): void
       + setRefViewCtrl(ItfViewCtrl): void
          - - bPane: BorderPanebtn_backLoginPage: ButtonFaceIDCtrl
          - - ~ btn_login: ButtonImgvWebCam: ImageViewrefViewCtrl: ItfViewCtrl
          + - + afficheFrame(BufferedImage): voidbackLoginPage(ActionEvent): voidinitialize(): void
          - + + loginFaceID(ActionEvent): voidquitter(): voidsetRefViewCtrl(ItfViewCtrl): void

```
+ quitter(): void«interface»ItfAdminCtrl
+ + setRefViewCtrl(ItfViewCtrl): voidshowRobotImg(WritableImage): void + + quitter(): voidsetRefViewCtrl(ItfViewCtrl): void«interface»ItfClientCtrl
+ showRobotImg(WritableImage): void
+ afficheFrame(BufferedImage): voidItfConfigFaceIDCtrl«interface»
+ + quitter(): voidsetRefViewCtrl(ItfViewCtrl): void + + + afficheFrame(BufferedImage): voidquitter(): voidsetRefViewCtrl(ItfViewCtrl): voidItfFaceIDCtrl«interface»
```
```
ItfKonnectCtrl«interface»
+ + quitter(): voidsetRefViewCtrl(ItfViewCtrl): void
```
```
«interface»ItfLoginCtrl
+ + quitter(): voidsetRefViewCtrl(ItfViewCtrl): void
ItfRegisterCtrl«interface»
+ + quitter(): voidsetRefViewCtrl(ItfViewCtrl): void
ItfScreenshotCtrl«interface»
+ + + getImgv_screenshot(): ImageViewquitter(): voidsetRefViewCtrl(ItfViewCtrl): void
```
```
+ afficheErreur(String): void«interface»ItfView Ctrl
+ + + afficheFrame(BufferedImage): voidcheckUser(String, String): StringconnectionFaceID(): String
+ + + disconnect(): voidgetRefCtrl(): ItfCtrlisControlerConnect(): String
+ + + lireMessage(): StringregisterUser(String, String): booleanscreenshot(WritableImage): void
+ + + showAdminView(): voidshowClientView(): voidshowConfigFaceIDView(): void
+ + + showFaceIDView(): voidshowKonnectView(): voidshowLoginView(): void
+ + + + showRegisterView(): voidshowRobotImg(WritableImage): voidshowScreenshotView(): voidstartWebcam(): void
+ + stopWebcam(): voidtakeScreenshot(): void
```
- - bPane: BorderPanebtn_loginPage: ButtonKonnectCtrl
- ~ - btn_registerPage: ButtonrefViewCtrl: ItfViewCtrlloginPage(ActionEvent): void
+ - + quitter(): voidregisterPage(ActionEvent): voidsetRefViewCtrl(ItfViewCtrl): void
    - - bPane: BorderPanebtn_backKonnectPage: ButtonLoginCtrl
    - - ~ btn_faceIDLogin: Buttonbtn_login: ButtonrefViewCtrl: ItfViewCtrl
    - - - txf_password: PasswordFieldtxf_username: T extFieldbackKonnectPage(ActionEvent): void
    - - + faceIDLogin(ActionEvent): voidlogin(ActionEvent): voidquitter(): void
    + setRefViewCtrl(ItfViewCtrl): void
       - - bPane: BorderPanebtn: ButtonRegisterCtrl
       - - - ~ btn_submitRegister: Buttonpwf_confirmPassword: PasswordFieldpwf_password: PasswordFieldrefViewCtrl: ItfViewCtrl
       - + + txf_username: T extFieldquitter(): voidsetRefViewCtrl(ItfViewCtrl): void
       - submitRegister(ActionEvent): void
          - - bPane: BorderPanebtn_backClientPage: ButtonScreenshotCtrl
          - - ~ - btn_savePicture: Buttonimgv_screenshot: ImageViewrefViewCtrl: ItfViewCtrltxf_urlScreenshot: T extField
          - + + backClientPage(ActionEvent): voidgetImgv_screenshot(): ImageViewquitter(): void
          - + + savePicture(ActionEvent): voidsetImgv_screenshot(ImageView): voidsetRefViewCtrl(ItfViewCtrl): void
- - adminView: StageclientView: StageView Ctrl
- - - configFaceIDView: StagefaceIDView: StagekonnectView: Stage
- - - loginView: StagerefCtrl: ItfCtrlrefCtrlAdmin: ItfAdminCtrl
- - - refCtrlClient: ItfClientCtrlrefCtrlConfigFaceID: ItfConfigFaceIDCtrlrefCtrlFaceID: ItfFaceIDCtrl
- - - refCtrlKonnect: ItfKonnectCtrlrefCtrlLogin: ItfLoginCtrlrefCtrlRegister: ItfRegisterCtrl
- - - refCtrlScreenshot: ItfScreenshotCtrlregisterView: StagescreenshotView: Stage
+ + + afficheErreur(String): voidafficheFrame(BufferedImage): voidcheckUser(String, String): String
+ + + connectionFaceID(): Stringdisconnect(): voidgetRefCtrl(): ItfCtrl
+ + + - initialize(): voidisControlerConnect(): StringlireMessage(): StringloadAdminView(): AdminCtrl
- - - loadClientView(): ClientCtrlloadConfigFaceIDView(): ConfigFaceIDCtrlloadFaceIDView(): FaceIDCtrl
- - - - loadKonnectView(): KonnectCtrlloadLoginView(): LoginCtrlloadRegisterView(): RegisterCtrlloadScreenshotView(): ScreenshotCtrl
+ + + registerUser(String, String): booleanscreenshot(WritableImage): voidsetRefCtrl(ItfCtrl): void
+ + + + showAdminView(): voidshowClientView(): voidshowConfigFaceIDView(): voidshowFaceIDView(): void
+ + + + showKonnectView(): voidshowLoginView(): voidshowRegisterView(): voidshowRobotImg(WritableImage): void
+ + + showScreenshotView(): voidstartWebcam(): voidstopWebcam(): void
+ + takeScreenshot(): voidViewCtrl(Stage)

```
Danilo Anzile - G224.11.2021Version 2Konnect - Client
```
```
-refCtrlClient
```
```
~refViewCtrl
```
```
~refViewCtrl
```
```
~refViewCtrl
```
```
-refCtrlKonnect
-refCtrlConfigFaceID -refCtrlFaceID
```
```
-refCtrlLogin
-refCtrlAdmin
```
```
~refViewCtrl
```
```
-refCtrlRegister
```
```
~refViewCtrl
```
```
-refCtrlScreenshot
```
```
~refViewCtrl ~refViewCtrl
~refViewCtrl
```

#### 7.1.3 Diagramme de classes Wrk (client)

Chaque acteur (Web Cam, Controlleur Xbox...) contient son propre worker, tous les workers
sont regroupées dans un worker principal nommée « Wrk ».

#### 7.1.4 Diagramme de classes Beans (client)

Pour finir, on a eu besoins d’un beans pour la manette.

### 7.2 Reverse engineering serveur

#### 7.2.1 Diagramme de classes MVC2 (serveur)

Le diagramme suivant est le diagramme MVC2 contenant en jaune les classes principales de
l’IHM, en vert celles du contrôleur puis en bleu les classes principales du worker. Le worker
contiens des classes non-cités dans le diagramme MVC2 et développées dans le point « 7.2.3 »
Diagramme de classes Wrk ».

```
class Wrk
```
```
ClientTCPWrk Thread
```
- - - in: BufferedReaderout: BufferedWriterrefWrk: ItfWrkClientTCP
- - running: volatile booleansocket: volatile Socket
+ + + attendre(long): voidconnectToServer(String, int): booleandisconnect(): void
+ + + lireMessages(): Stringrun(): voidsendDirection(String): void
+ + sendUser(String, String): StringsetRefWrk(ItfWrkClientTCP): void

```
ClientUDPWrk Thread
```
- - - buf: byte ([]) = new byte[64000]imageCourrante: WritableImagerefWrk: ItfWrkClientUDP
- - running: volatile booleansocket: DatagramSocket
+ + + getImageCourrante(): WritableImageisRunning(): booleanrun(): void
+ + + setRefWrk(ItfWrkClientUDP): voidsetRunning(boolean): voidshowImage(BufferedImage): void
- couleur: String **DetectionCouleur**
~ ~ ~ seuilB: intseuilG: intseuilR: int
+ + + DetectionCouleur(String, int, int, int)getCouleur(): StringgetSeuilB(): int
+ + + getSeuilG(): intgetSeuilR(): intsetCouleur(String): void
+ + + setSeuilB(int): voidsetSeuilG(int): voidsetSeuilR(int): void

```
ItfWrkClientTCP «interface»
```
```
ItfWrkClientUDP «interface»
+ showRobotImg(WritableImage): void
```
```
«interface» ItfWrkCtrl
+ + + checkUser(String, String): Stringdisconnect(): voidisControlerConnect(): String
+ + + lireMessage(): StringregisterUser(String, String): booleanrobotDirection(String): void
+ + + startWebcam(): booleanstopWebcam(): booleantakeScreenshot(): void
+ + + userLogout(): voidutilisateurTrouver(): StringxboxControlerIsConnected(): boolean
```
```
ItfWrkMyWebCam «interface»
+ + recoitErreur(String): voidrecoitFrame(BufferedImage): void
ItfWrkXboxControler «interface»
+ robotDirection(String): void
```
```
MyWebCam Thread
```
- - - afficheCouleur: booleancouleurDetectee: StringdetectC: DetectionCouleur
- - - detecteFace: booleandetectionCouleur: booleanduplicate: boolean
- + - enregistrementStarted: booleanFPS: double = 15.0 {readOnly}frame1: MBFImage
- - - height: intimg2: BufferedImagenoirBlanc: boolean
- - - oldCouleur: Stringpaused: volatile booleanreading: volatile boolean
- - - refWrk: ItfWrkMyWebCam {readOnly}textAAfficherSurDuplic: String = ""vc1: VideoCapture
- - - width: intafficheCouleur(MBFImage): BufferedImageanalyseBlanc(int[]): String
- + - analyseBleu(int[]): StringanalyseImage(int[]): StringanalyseNoir(int[]): String
- - - analyseRouge(int[]): StringanalyseVert(int[]): Stringattend(int): void
+ - - captureImage(File): BufferedImagechangeFluxNB(): voidcreateWebcam(): boolean
+ - + detectCouleur(BufferedImage): StringduplicateFlux(MBFImage, String): BufferedImageduplicateFlux(boolean, String): boolean
+ + + getDetectC(): DetectionCouleurgetFrame1(): MBFImagegetHeight(): int
+ + + getImg2(): BufferedImagegetWidth(): intimageWebcam(): BufferedImage
+ + + isAfficheCouleur(): booleanisDetecteFace(): booleanisDetectionCouleur(): boolean
+ + + isNoirBlanc(): booleanisPaused(): booleanisReading(): boolean
+ - + MyWebCam(int, int, Wrk)pixelise(MBFImage): int[]pixelise(BufferedImage): int[]
+ - + recoitFluxPlayer(BufferedImage): voidreconnaitFace(): voidrun(): void
+ + + setAfficheCouleur(boolean): voidsetDetectC(DetectionCouleur): voidsetDetecteFace(boolean): void
+ + + setDetectionCouleur(boolean): voidsetHeight(int): voidsetNoirBlanc(boolean): void
+ + + setPaused(boolean): voidsetReading(boolean): voidsetWidth(int): void
- - traite(int[], String): int[]traiteImage(int[]): int[]

```
+ HEIGHT: int = 480 {readOnly} Wrk
```
- - - refClientTCPWrk: ClientTCPWrkrefClientUDPWrk: ClientUDPWrkrefCtrl: ItfCtrl
- - - refXboxControlerWrk: XboxControlerWrkuserConnected: booleanwebcam: MyWebCam
+ + WIDTH: int = 640 {readOnly}checkUser(String, String): String
+ + + disconnect(): voidinitialiser(): voidisControlerConnect(): String
+ + + lireMessage(): StringrecoitErreur(String): voidrecoitFrame(BufferedImage): void
+ + + registerUser(String, String): booleanrobotDirection(String): voidsetRefClientTCPWrk(ClientTCPWrk): void
+ + + setRefCtrl(ItfCtrl): voidsetRefXboxControlerWrk(XboxControlerWrk): voidshowRobotImg(WritableImage): void
+ + + startWebcam(): booleanstopWebcam(): booleantakeScreenshot(): void
+ + + userLogout(): voidutilisateurTrouver(): StringWrk()
+ xboxControlerIsConnected(): boolean

```
XboxControlerWrk Thread
```
- - - isStart: booleanmagnitudeDroite: doublemagnitudeGauche: double
- - + refWrk: ItfWrkXboxControlerxc: XboxController = new XboxController() {readOnly}connecterManette(): void
+ + + disconnect(): voidisIsStart(): booleansetItfWrkXboxControler(ItfWrkXboxControler): void
+ XboxControlerWrk()

```
Danilo Anzile - G224.11.2021Version 2
Konnect - Client
```
```
-refClientUDPWrk
```
```
-refWrk
```
```
-refXboxControlerWrk
```
```
-refWrk
```
```
-refWrk
```
```
-refWrk
```
```
-webcam
```
```
-refClientTCPWrk
```
```
-detectC
```
```
class beans
```
```
XboxButton
```
- nom: String
- pressed: boolean
+ getNom(): String
+ isPressed(): boolean
+ setPressed(boolean): void
+ XboxButton(String, boolean)

```
Danilo Anzile - G2
24.11.2021
Version 2
Konnect - Client
```

#### 7.2.2 Diagramme de classes Ihm (serveur)

Chaque IHM possède son propre contrôleur et sa propre interface. En total il y a donc 2
contrôleurs de 2 IHM différents (MainCtrl et SecondCtrl). Le contrôleur nommé « ViewCtrl »
regroupe tous les contrôleurs des IHM.


#### 7.2.3 Diagramme de classes Wrk (serveur)

Chaque acteur (Base de données, Robot...) contient son propre worker, tous les workers sont
regroupées dans un worker principal nommée « Wrk ».

#### 7.2.4 Diagramme de classes Beans (serveur)

Du coté serveur il y a trois beans différents.
Le beans « MyRobot » est liée au robot.
Les beans « Photo » et « User » sont des beans venant de la base de données contentant les
utilisateurs ayant accès à l’application.


### 7.3 Remarques et commentaires

7.3.1 **Particularités de l’application (divergence avec le
cahier des charges et l’analyse des besoins et**
l'implémentation)

Au niveau du client, pas mal de chose en changé par rapport au cahier des charges de bases.
Premièrement, la Kinect a été abandonnée et remplacé par une webcam standard. Ce choix a
été fait par manque de temps pour trouver une solution afin de récupérer le flux vidéo en Java.
Un deuxième point qui a été changé, c’est le fait de pouvoir se connecter avec la
reconnaissance faciale. Par manque de temps et par difficulté nous l’avons remplacé par un
login avec reconnaissance de couleur. Pour ce faire, il suffit de montrer à la webcam une
couleur, soit le bleu (User) ou le rouge (Admin).

### 7.4 Erreurs rencontrées avec solution

#### 7.4.1 1. Liens avec la Kinect (Client)

Le test spécifique que nous avions à disposition n’arrivait pas a faire le lien avec la Kinect, du
coup nous avons dû cherché sur internet afin de trouvé un exemple qui montre comment
l’utilise dans Java. Après avoir trouvé un exemple qui fonctionne, nous avons enfin pu voir
comment Java gère la Kinect. Pour ce faire il nous a fallu installer le projet qui se trouve sur le
site https://research.dwi.ufl.edu/projects/ufdw/j4k/index.php avec les pilotes fournis directement
dans le projet.

#### 7.4.2 2. IHM mainView (Client)

Lors du démarrage de l’application client, le FXML n’arrivait pas à démarrer.


Pour résoudre ce problème j’ai dû déplacer tout ce qui se trouvait dans le contrôleur de la vue
principal et le mettre dans un autre contrôleur.

### 7.5 Erreurs résiduelles avec pistes de solutions

#### 7.5.1 3.Flux vidéo de la Kinect

Après plusieurs heures passées à chercher une solution pour récupérer le flux vidéo de la
Kinect, on a décidé de l’oublier temporairement et de prendre une webcam par manque de
temps pour trouver une solution. Si à la fin du projet il me reste du temps, je vais continuer a
essayé de trouver une solution.

## 8 Autoévaluation

### 8.1 Autoévaluation de l’apprenti (Danilo)

J’ai beaucoup aimé travailler sur ce module. Dommage que nous ayons commencé un peu trop
tard l’implémentation de notre application. J’ai beaucoup apprécié le fait que ce soir un projet
conçu de A à Z par les apprentis, ça permet d’avoir une satisfaction à la fin du projet en voyant
de quoi on est capable.

### 8.2 Autoévaluation de l’apprenti (Joel)

J’ai beaucoup aimé travailler sur ce projet, malheureusement j’avais beaucoup de mal avec
l’organisation et la gestion du projet. La partie programmation du projet c’est très bien déroulé.

### 8.3 Autoévaluation de l’équipe de développement

L’équipe est fière du résultat avec le peu de temps qu’on a eu.

## 9 Conclusion

### 9.1 Conclusion de l’apprenti (Danilo)

Ce module m’a permis d’apprendre à faire des diagrammes de classe et d’apprendre à gérer
tout ce qui à avoir avec les plannings ainsi qu’à apprendre de nouveau fonctionnement sur Java
tel que les Threads.

### 9.2 Conclusion de l’apprenti (Joel)

Ce module m’a permis d’apprendre la façon de m’organiser pendant un projet de longue durée.
J’ai aussi appris à faire correctement des diagrammes en fonction du code Java.


### 9.3 Conclusion de l’équipe de développement

Malheureusement, nous n’avons pas pu faire tout ce que nous avions prévu mais nous sommes
fières du résultat final même si saurait pu être mieux.

## 10 Annexes

### 10.1 Annexe 1 : Journal de travail



### 10.2 Annexe 2 : Planning....................................................................................................

### 10.3 Annexe 3 : ToDoList


### 10.4 Annexe 4: Exercices

#### 10.4.1 Exercice 1 :

1) Quel est ce type de diagramme et à quoi peut-il servir?
C’est un diagramme MVC2
2) Pourquoi y-a-t-il des couleurs? À quoi cela sert?
Pour definir les differents types de classe (worker, beans, controler, ihm).
3) Comment appelle-t-on ces flèches et à quoi elles correspondent? Que peuvent-elles
bien dire?
droite: attribut referance a une classe
trait-tié: referance interface
4) À quoi sert le contenu de chacune de ces boîtes? Que représentent-elles?
Le contenu dans les boites represente les methodes Java.
5) Quels sont les avantages de faire un diagramme de ce genre et dans le cas présent, de
cette manière?
D'avoir une bonne vue d'ensemble du projet

#### 10.4.2 Exercice 2 :

1) Quel Est-ce Type de diagramme et à quoi peut-il servir?
C’est un diagramme Use-Case, permettant d’avoir toutes les actions du programme.
2) Pourquoi y-a-t-il des couleurs?
Chaque couleur concerne un autre type d’action.
3) Comment appelle-t-on ces flèches et à quoi elles correspondent?
Les flèches représentent des relations.
4) Quels sont les avantages de faire un diagramme de ce genre?
De connaitre toutes les actions possibles dans le programme et ce que ça implique.
5) Quels sont les modifications à faire sur ce diagramme pour en obtenir une meilleure
version?
Orthographe et langage. Du HTTP/S


#### 10.4.3 Exercice 3 :

1. Comment réaliser la génération du code du diagramme de classes donné dans le projet
    EA << 326_UML_Ex03-04.eap>>?
Pour débuter il faut ouvrir le fichier à gérer.

Ensuite il faut aller dans l’onglet “Code” puis cliquer sur “Generate All”.


Puis il faut cocher l’option “Auto Générâtes Files” et définir l’endroit de stockage. Il est souhaité
de sélectionner toutes les classes.
Pour confirmer le paramétrage et générer les classes il faut cliquer sur “Generate”.

Résultat après avoir générer les classes.

2. Comment le récupérer dans un projet NetBeans?
Il est possible de simplement drag-and-drop le ficher générer dans un projet.

#### 10.4.4 Exercice 4 :

1. Comment réaliser le reverse du code donné en un diagramme de classes dans le projet
    EA << 326_UML_Ex03-04.eap>>?

Pour réaliser un reverse il faut se rendre dans l’onglet “Code”, cliquer sur “Import Code” et puis
cliquer sur “Java Files”. Il faut sélectionner le ou les fichiers code pour effectuer le reverse.


Un pop-up affichera les différentes modifications.

Résultat final.


2. Pourquoi faire ceci?

Pour les problèmes que l’on rencontre dans notre code, c’est plus facile de les voir sur une
représentation visuelle.

3. Quels sont les différences entre le diagramme de conception réalisé précédemment et
    ce nouveau?
Le dernier est plus rapide à faire et plus facile.

#### 10.4.5 Exercice 5 :

1. Quel est ce type de diagramme et à quoi peut-il servir?
C’est un diagramme de séquence d’interaction permettant de modéliser les interactions entre
les objets dans un cas d’utilisation unique.
2. Comment appelle-t-on ces flèches et à quoi elles correspondent? Que peuvent-elles
bien dire?
Les flèches correspondent à différents affichages.
3. Quels sont les avantages de faire un diagramme de ce genre?

Il permet de référencer des interactions courantes et de spécifier facilement des scénarios
alternatifs ou parallèles en utilisant des fragments d'interaction.

4. Quels sont les modifications à faire sur ce diagramme pour en obtenir une meilleure
    version?
Mettre le nom des classes du client HTML-JS et du serveur PHPO


#### 10.4.6 Exercice 6 :

1. Quel est ce type de diagramme et à quoi peut-il servir?
C’est un diagramme d’activité.
2. Comment appelle-t-on ces flèches et à quoi elles correspondent? Que peuvent-elles
bien dire?
L’ordre des actions.
3. Quels sont les avantages de faire un diagramme de ce genre?
On voit l’ordre dans lequel toutes les opérations sont faites.

#### 10.4.7 Exercice 7 :

1. Quel est le type de base de données et avec quel outil ce modèle a été fait?
MYSQL et l’outil utilisé est MYSQL Workbench
2. Comment appelle-t-on les différents éléments et à quoi ils correspondent? Que
peuvent-ils bien dire?
Les carrées sont des Tables


Les flèches sont des relations
Sur les côtés de la table prête des liens on trouve le type de relation que la table a avec celle
qui est à l’autre bout du lien. (Relations : 0,1 ;1,1 ;1,N ;0,N).

3. Quels sont les avantages de faire un modèle de ce genre?
Permet d’exporter directement le schéma vers la base de données.
4. Quels sont les modifications à faire sur ce modèle pour en obtenir une meilleure version
?
Nommage

#### 10.4.8 Exercice 8 :

1. Quel est ce type de diagramme et à quoi peut-il servir?
Diagramme de séquence
2. Pourquoi y-a-t-il des couleurs? À quoi cela sert?
Chaque couleur représente une autre classe?
3. Comment appelle-t-on ces flèches et à quoi elles correspondent? Que peuvent-elles
bien dire?
Chaque flèche représente l’appelle d’une méthode.
4. Quels sont les avantages de faire un diagramme de ce genre?
Il est très facile à savoir ce qu'il faut coder dans les méthodes.


#### 10.4.9 Exercice 11 :

1. Tester une connexion Bluetooth entre deux ordinateurs de la salle
2. Tester, expliquer et documenter le projet RS-232 par listener
a) Récupérer le dossier complet du test technologique <>
b) Créer un projet NetBeans et étudier le code fourni
c) Réaliser un reverse du projet dans EA


d) Etudier la conception de classes du wrk dans EA
e) Tester le programme fourni et visualiser les Thread exécutés
f) Réaliser votre propre JAVADoc dans le code


