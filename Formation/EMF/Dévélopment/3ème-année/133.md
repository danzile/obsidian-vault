# 133 - Réaliser des

# applications Web en Session-

# Handling

## Rapport de projet

## Carman Joël et Anzile Danilo

## Dèrnière modification le 08.05.

## Module du 24.03.2022 au 0 3.05.


## La Table des Matières


- 1 INTRODUCTION ET CONTEXTE DU PROJECT
- 2 ANALYSE À FAIRE COMPLÈTEMENT AVEC EA
- 2.1 USE CASE AVEC LES EXPLICATIONS DES CAS POUR LES APPLICATIONS
- 2.2 ACTIVITY DIAGRAM
- 2.3 MAQUETTES DU PROJET
- 2.4 SÉQUENCE SYSTEM GLOBAL
- 3 CONCEPTION À FAIRE COMPLÉTEMENT AVEC EA
- 3.1 CLASS DIAGRAM COMPLET AVEC LES EXPLICATIONS DE CHAQUE APPLICATION
- 3.1.1 ARCHITECTURE CLIENT
- 3.1.2 ARCHITECTURE DOUANIÈRE
- 3.1.3 ARCHITECTURE ÉTAT-MAJOR
- 3.2 NAVIGATION DIAGRAM COMPLÈTE AVEC LES EXPLICATIONS DES APPLICATIONS
- 4 BASES DE DONNÉES
- 4.1 MODÈLES ER DANS EA..............................................................................................................
- 4.2 MODÈLES DDL DANS EA
- 4.3 MODÈLES WORKBENCH MYSQL
- 4.4 REQUÊTES SQL UTILES
- 5 IMPLÉMENTATION DES APPLICATIONS (CLIENT)
- 5.1 PARTIES JSP SUR SERVEUR TOMCAT
- 5.1.1 PARTIE CONNEXION ET INSCRIPTION
- 5.1.2 PARTIE SPOTIFY
- 5.2 PARTIES JS DE CHACUN............................................................................................................
- 5.2.1 PARTIE CONNEXION ET INSCRIPTION
- 5.2.2 PARTIE SPOTIFY
- 6 IMPLÉMENTATION DE L'APPLICATION (DOUANIER)
- 6.1 PARTIE SERVLET SUR SERVEUR TOMCAT COMMUN
- 7 IMPLÉMENTATION DES APPLICATIONS (REST)
- 7.1 PARTIES REST ET JDBC MYSQL SUR COMPTE TIZOO DE CHACUN
- 7.1.1 PARTIE CONNEXION ET INSCRIPTION
- 7.1.2 PARTIE SPOTIFY
- 8 HÉBERGEMENT
- 9 INSTALLATION DU PROJET COMPLET AVEC LES 5 APPLICATIONS
- 10 OUTILS, LANGAGES
- 10.1 OUTILS
- 10.2 LANGAGES..........................................................................................................................
- 11 AUTO-ÉVALUATIONS ET CONCLUSIONS
- 12 TESTS TECHNOLOGIQUES SELON LES EXERCICES
- 12.1.1 EXERCICE
- 12.1.2 EXERCICE
- 12.1.3 EXERCICE
- 12.1.4 EXERCICE 4 – JDBC
- 12.1.5 EXERCICE 5 – BEAN
- 12.1.6 EXERCICE 6 – SERVLET SIMPLE
- 12.1.7 EXERCICE 7 – JSP-SERVLET-SESSION


## 1 INTRODUCTION ET CONTEXTE DU PROJECT

Le projet que nous allons réaliser nous permettra d'interagir avec notre compte Spotify. Pour accéder à

cette page il faudra d'abord de connecter avec un compte interne. Lorsqu'on est connecté, on aura la

possibilité de voir la musique qu'on écoute actuellement, rechercher et jouer des musiques ainsi que les

mettre à la suite de l'écoute.

## 2 ANALYSE À FAIRE COMPLÈTEMENT AVEC EA

## 2.1 USE CASE AVEC LES EXPLICATIONS DES CAS POUR LES APPLICATIONS

Visiteur Le visiteur a le droit de se loger ou de créer un compte.

```
Utilisateur L’utilisateur a le droit d’utiliser l’interface de Spotify et faire beaucoup
d’action sur leur compte.
```
```
Douanier Le Douanier va jouer un rôle d’intermédiaire et de gestion de session. Chaque
requête vers le Rest va passer par lui.
```
```
Etat Major L’Etat major aura une connexion avec la base de données pour la connexion
des utilisateurs et une connexion avec l’api de Spotify.
```
DB La base de données contient les informations des utilisateurs.

```
uc Use Case Global
```
```
HTTP Intranet HTTPS Internet
```
```
:user
```
```
:visitor
```
```
usecase_client usecase_douanier usecase_etat-major
```
```
:Database
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
Idem pour Ap 2 Idem pour Ap 2
```
```
:Sign Up
```
```
:login
```
```
:logout
```
```
getCurrentTrack
```
```
:Sign Up
```
```
:login
```
```
:logout
```
```
:Log In
```
```
:Sign up
```
```
postSkipToNext
```
```
postSkipToPrevious
```
```
putStartResume
```
```
getAvalaibleDevice
```
```
getRecentlyPlayed
```
```
:getAvalaibleDevice :getAvalaibleDevice
```
```
:getCurrentTrack
```
```
:getCurrentTrack
```
```
:postSkipToNext :postSkipToNext
```
```
:postSkipToPrevious :postSkipToPrevious
```
```
:putStartResume :putStartResume
```
```
API Spotify
```
```
findSong
```
```
getRecentlyPlayed
```
```
findSong
```
```
getRecentlyPlayed
```
```
findSong
```

## 2.2 ACTIVITY DIAGRAM

Dans ce diagramme d'activité nous avons montré ce qui se passe quand on souhaite voire les musique

qu'on a récemment écoutée.

## 2.3 MAQUETTES DU PROJET

Voici les maquettes du projet :

Nous avons décidé de répartir sur deux pages. Un page se charge de la connexion et des créations de

compte. Tandis que l'autre est le cœur du projet. Depuis cette page on peut interagir avec notre compte

Spotify.

```
act getRecentlyPlayed
```
```
User Client Douanier EtatMajeur API Spotify
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
getRecentlyPlayed
Click Recently
Played
```
```
Valide Session
getRecentlyPlayed
```
```
DisplayError
```
```
End
```
```
ValidInformation
```
```
DisplayPopup
```
```
listeRecentlyPlayed listRecentlyplayed
```
```
getRecentlyPlayed
```
```
custom Clients
```
```
Login
```
```
Username
Password
Login
```
```
Home
```
```
TrackImage
```
```
Log out
```
```
Sign Up
```
```
Sign Up
```
```
Sign Up
Cancel
```
```
Username
Password
Repeat Password
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
previous Play Next
Repet
```
```
Search
```
```
UserName
```
```
Popup : Liste des recherche Popup : Liste for devices
```
```
Recently Played AvalaibleDevices
```
```
Popup : Liste Avalaible Devices
```
```
«navigate»
```
```
«navigate»
```
```
«navigate»
```
```
«navigate»
```
```
«navigate»
```
```
«navigate»
```

## 2.4 SÉQUENCE SYSTEM GLOBAL

Voici le diagramme de séquence dès qu’on clique sur le bouton RecentlyPlayed.

```
sd getRecentlyPlayed
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
user API Spotify
```
```
client Douanier etat-majeur
```
```
alt sessionKO
```
```
alt list == null
```
```
getRecentlyPlayed()
```
```
afficherErreur()
```
```
verifyListPlayed()
```
```
getRecentlyPlayed()
```
```
getRecentlyPlayed()
```
```
CheckSession ()
```
```
afficherPopup()
```
```
listeRecentlyPlayed()
```
```
listeRecentlyPlayed()
```
```
listeRecentlyPlayed()
```
```
afficherErreur()
```

## 3 CONCEPTION À FAIRE COMPLÉTEMENT AVEC EA

## 3.1 CLASS DIAGRAM COMPLET AVEC LES EXPLICATIONS DE CHAQUE APPLICATION

## 3.1.1 ARCHITECTURE CLIENT

Voici l’architecture cliente comme nous l’avons imaginé.

```
web Architect Client JSP-js
```
```
index.jsp
```
```
«javascript object»
ctrl_enregistrement.js
```
```
connexion.jsp
```
```
enregistrement.jsp
```
```
Douanier
```
```
«javascript object»
wrk_enregistrement.js
```
```
«javascript object»
ctrl_connexion.js
```
```
«javascript object»
wrk_connexion.js
```
```
BetterSpotify - Joel et Da nilo - Version : 1.0 - 04.04.
```
```
«link»
```
```
«link» «submits»
```
```
«link»
```
```
«submits»
```

## 3.1.2 ARCHITECTURE DOUANIÈRE

Voici l’architecture du douanier.

```
class Douanier
```
```
UserManager
```
- BASE_URI: String = "http://localho... {readOnly}
- client: Client
- webTarget: WebTarget
+ close(): void
+ login(String): String
+ signup(String): String
+ UserManager()

```
HttpServlet
Douanier
```
- ctrl: Ctrl
~ users: UserManager = new UserManager()
# doGet(HttpServletRequest, HttpServletResponse): void
# doPost(HttpServletRequest, HttpServletResponse): void
+ Douanier()
+ getServletInfo(): String
# processRequest(HttpServletRequest, HttpServletResponse): void

```
Wrk
```
- refCtrl: ItfCtrlWrk
- tcpClient: TCPClient
+ connect(String, int): boolean
+ exit(): void
+ getDevice(): void
+ getNext(): void
+ getPrevious(): void
+ getSong(): void
+ putStartResume(): void
+ Wrk()
    «property set»
+ setRefCtrl(ItfCtrlWrk): void

```
«interface»
ItfWrkCtrl
```
```
+ connect(): boolean
+ getCurrentTrack(): void
+ getDevice(): void
+ getNext(): void
+ getPrevious(): void
+ getSong(): void
+ putStartResume(): void
```
```
Ctrl
```
- refWrk: ItfWrkCtrl
+ connect(String, int): boolean
+ Ctrl()
+ disconnect(): void
+ exit(): void
+ getCurrentTrack(): void
+ getDevices(): void
+ getNext(): void
+ getPrevious(): void
+ getSong(): void
+ putStartResume(): void
+ showError(): void
+ showInfo(): void

```
«interface»
ItfCtrlWrk
```
```
+ showError(String, String): void
+ showInfo(String[]): void
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
-ctrl
```
```
~users
```
```
-refWrk
```
```
-refCtrl
```

## 3.1.3 ARCHITECTURE ÉTAT-MAJOR

Voici l’architecture de l’état-major avec les classe que nous imaginons implémenté.

```
class EtatMajor
```
```
wrk::Wrk
```
- wrkDB: WrkDB

```
+ addUser(String): boolean
+ checkUser(String): boolean
```
- jsonToUser(String): User
+ Wrk()

```
wrk::WrkDB
```
- jdbcConnection: Connection

```
+ addUser(): boolean
```
- dbConnect(): boolean
- dbDisconnect(): boolean
+ readUser(String): User
+ WrkDB()

```
«interface»
wrk::ItfWrkCtrl
```
```
+ addUser(String): boolean
+ checkUser(String): boolean
```
```
Application
rest::ApplicationConfig
```
- addRestResourceClasses(Set<Class<?>>): void
+ getClasses(): Set<Class<?>>

```
rest::ManageUser
```
- context: UriInfo
- ctrl: ItfCtrlRest

```
+ login(String): String
+ ManageUser()
+ signup(String): String
```
```
ctrl::Ctrl
```
- wrk: ItfWrkCtrl

```
+ Ctrl()
+ login(String): boolean
+ signup(String): boolean
```
```
«interface»
ctrl::ItfCtrlRest
```
```
+ login(String): boolean
+ signup(String): boolean
```
```
beans::User
```
- password: String
- username: String

```
+ toString(): String
+ User()
+ User(String)
+ User(String, String)
«property get»
+ getPassword(): String
+ getUsername(): String
«property set»
+ setPassword(String): void
+ setUsername(String): void
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
-ctrl
```
```
-wrkDB
```
```
-wrk
```

## 3.2 NAVIGATION DIAGRAM COMPLÈTE AVEC LES EXPLICATIONS DES APPLICATIONS

Voici notre diagramme de navigation. Nous avons une page de connexion qui redirige ensuite vers le

douanier. Si l’utilisateur à le droit de se connecter, il sera redirigé vers la page home. Ensuite de cette

page il pourra faire des actions qui vont appeler l’état-major en passant par le Douanier.

## 4 BASES DE DONNÉES

## 4.1 MODÈLES ER DANS EA..............................................................................................................

Pour ce projet nous avons choisis de faire avec une API c’est pourquoi dans la base de données il y a

qu’une table pour le login d’utilisateur.

```
act Global Navigation
```
```
password matches
password hash
```
```
index.jsp
notes
This is the main page. It
contains a form for login as
well as a button which
redirects to the sign up page.
In case there was an error,
there will be an information
displayed.
```
```
Douanier
notes
The Douanier is used for multiple purpose.
He will check user - password pairs, create
new users to be inserted into the database,
send commands to the index.js (API Spotify)
and returns result to client. The most
important feature is the session
management.
```
```
EtatMajor
notes
The EtaMajor is
used to store all
the usernames
and the hashed
passwords.
```
```
home.jsp
notes
The home page
will prepare
some buttons to
contr
```
```
signup.jsp
notes
To sign up a new account
this page will be used. In
case there was an error,
there will be an
information displayed.
```
```
create session
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
index.js
notes
This page is the main page
of connection for the api.
There are a lot more files
that are going to be called.
```
```
sign up
«redirect»
```
```
return results
«JSON»
```
```
logout
«redirect»
```
```
sign up
«submits»
```
```
executeActions
«submits»
```
```
ask for user
«JSON Rest»
```
```
yes
```
```
«redirect»
```
```
logout - destroy session
«submits»
```
```
no
```
```
«JSON»
```
```
executeActions
«submits»
```
```
send login data to Douanier
«submits»
```
```
return User
```
```
return results
«JSON»
```

## 4.2 MODÈLES DDL DANS EA

## 4.3 MODÈLES WORKBENCH MYSQL

Voici la base de données comme nous l'avons imaginé.

```
erd Model E-R
```
```
T_Utilisateurs
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
class DDL
```
```
T_utilisateurs
```
```
«column»
Login_utilisateur: TEXT
Password_utilisateur: TEXT
Pk_utilisateur: INTEGER
```
```
«PK»
+ PK_T_utilisateurs()
```
```
BetterSpotify - Joel et Danilo - Version : 1.0 - 04.04.
```
```
Wrk
```
```
+ addUser(): void
+ verifyUser(): void
```
```
Insert into t_utilisateurs ( ... ) va lues ( ... )
```
```
Select from t_utilisateurs where login_utilisateur=....
```

## 4.4 REQUÊTES SQL UTILES

Voici les requêtes utiles :

Recherche d'un utilisateur : SELECT * FROM t_utilisateurs WHERE login=?

Ajout d'un utilisateur dans la base de donnée : INSERT INTO t_utilisateurs (login,

password, clientID, clientSecret) values (?, ?, ?, ?)

## 5 IMPLÉMENTATION DES APPLICATIONS (CLIENT)

## 5.1 PARTIES JSP SUR SERVEUR TOMCAT

## 5.1.1 PARTIE CONNEXION ET INSCRIPTION

Nous avons décidé de faire cette page en jsp pour permettre de gérer plus facile sessions. Pour envoyer

les informations vers le servlet nous avons utilisé un form comme dans l’exercice 7. Le voici :

<form method="post" action="https://carmanj.emf-

informatique.ch/javaDouanier/douanierServlet">

Pour finir nous avons décidé de mettre le douanier sur notre héberger web pour continuer les tests.

## 5.1.2 PARTIE SPOTIFY

Pour la page d’accueil nous avons décidé de mettre en jsp pour assurer la gestion des sessions. Voici

ce que nous avons mis pour gérer les sessions :

Pour commencer on va tester _s’il y a une session._

<% if (session != null) {
String user = (String) session.getAttribute("username");

Ensuite on va vérifier si un nom d _’utilisateur a été_ attribué à la session. S _’il n’a pas été connecté_ ,

_l’utilisateur sera_ renvoyé vers la page de connexion.

if (user == null) {
response.sendRedirect("index.jsp");
}

_S’il y a un attribut avec le nom d’utilisateur,_ il va appeler une méthode js qui mettra le client_id et le

client_secret dans le localStorage.

else {
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("JavaScript");
// read script file
engine.eval(Files.newBufferedReader(Paths.get("/js/ctrl/indexCtrl.js"),
StandardCharsets.UTF_8));
Invocable inv = (Invocable) engine;


// call function from script file
inv.invokeFunction("writeAllClientInfo", session.getAttribute("client_id"),
session.getAttribute("client_secret"));
}
}%>

## 5.2 PARTIES JS DE CHACUN............................................................................................................

## 5.2.1 PARTIE CONNEXION ET INSCRIPTION

Il n’y a pas de partie js pour la partie client car tous les appels se font à travers un forms en jsp.

## 5.2.2 PARTIE SPOTIFY

Pour la partie Javascript du deuxième client, elle est composée de deux documents principaux, un

indexCtrl.js et un servicesHttp.js.

L’indexCtrl.js permet de gérer toutes les actions faites par l’utilisateur comme les actions qui vont être

faites lorsque l’utilisateur voudrait passer à la prochaine musique.

Dans le servicesHttp.js appelle le douanier pour effectuer les actions vers Spotify. Toute les actions

comme démarrer la musique, passé à la prochaine musique, rechercher une musique, etc...

Voici un exemple de l’action pour lancer une musique.

Nous pouvons voir que lorsque l’utilisateur effectue une recherche, il a la possibilité de jouer une

musique directement depuis la recherche

Lorsque l’utilisateur appui sur le bouton, il appelle directement la méthode

playFromSeache(id_musique).

<table class="table table-hover table-dark" style="">

<thead>


<tr>

<th scope="col">Album</th>

<th scope="col">Titre</th>

<th scope="col">Auteur</th>

<th scope="col">Play/Next</th>

</tr>

</thead>

<tbody class="tracksFind">

<tr>

<td scope="row">

<img

src="https://i.scdn.co/image/ab67616d00004851df4862f641044c61c4abe602"

/>

</td>

<td>Jefe</td>

<td>Ninho</td>

<td>

<button onclick="playFromSearch('6HTJgY7iWWlVLSDHsfHePf')">

<i class="fa-solid fa-play"></i>

</button>

</td>

</tr>

</tbody>

</table>

Cette méthode dans javascript va faire une requête à travers le serviceHttp.js pour informer l’api de

Spotify le changement de musique.

### /**

* Joue une musique recherchée

* @param {*} id

*/

function playFromSearch(id) {

var request =

"action=PLAYBACKQUEUE" +

"&uri=spotify:track:" +

id +

"&device_id=" +

deviceId();

callDouanierPostCallApi(request, null, playFromSearchResponse);

}

La méthode callDouanierPostCallApi(url,access_token, success,error) qui va faire un appelle au

douanier avec ajax.

### /**

* Call the api for type POST

* @param {*} url

* @param {*} access_token

* @param {*} successCallback


* @param {*} errorCallback

*

*/

function callDouanierPostCallApi(

url,

access_token,

successCallback,

errorCallback

) {

$.ajax({

type: "GET",

async: false,

crossDomain: true,

dataType: "application/json",

url: BASE_URL,

data:

"action=postCallApi" + "&access_token=" + access_token + "&url=" + url,

success: successCallback,

error: errorCallback,

});

}

Le douanier va rediriger la requête à l’état-major si l’utilisateur est bien connecté.

case "postCallApi":

urlSpotify = request.getParameter("uri").toString();

access_token = request.getParameter("access_token").toString();

device_id = request.getParameter("device_id").toString();

action = request.getParameter("action").toString();

url = new URL(

"https://carmanj.emf-

informatique.ch/javaEtatMajor2/webresources/gestionSpotify/postCallApi?access_token="

+ access_token + "&device_id=" + device_id + "&action=" + action + "&uri="

+ urlSpotify);

callEtatMajor(url, out);

break;

L’état-major va rediriger cette requête à l’api de Spotify qui va lancé la musique que nous avons

demandé.

### @GET

@Path("postCallApi")

@Produces(MediaType.APPLICATION_JSON + ";charset=utf-8")

/**

* Appel de l'api Spotify pour obtenir les données

*

* @param url de la requête pour Spotify

* @param token token de l'application

* @return un json contenant les données

*/


public String postCallApi(@QueryParam("access_token") String access_token, @QueryParam("action") String

action,

@QueryParam("device_id") String device_id, @QueryParam("uri") String uri) {

String resultat = "error";

String params = "";

HttpURLConnection connection = null;

try {

// Create connection new URL(urlSpotify)

URL urlSpotify = null;

switch (action) {

case "PLAY":

urlSpotify = new URL(PLAY);

break;

case "NEXT":

urlSpotify = new URL(NEXT);

params = "device_id=" + device_id;

break;

case "PREVIOUS":

urlSpotify = new URL(PREVIOUS);

params = "device_id=" + device_id;

break;

case "PLAYER":

urlSpotify = new URL(PLAYER);

params = "device_id=" + device_id;

break;

case "PLAYBACKQUEUE":

urlSpotify = new URL(PLAYBACKQUEUE);

params = "uri" + uri + "&device_id=" + device_id;

break;

### }

connection = (HttpURLConnection) urlSpotify.openConnection();

connection.setRequestMethod("POST");

connection.setRequestProperty("Content-Type",

"application/x-www-form-urlencoded");

connection.setRequestProperty("Authorization", "Bearer " + access_token);

connection.setUseCaches(false);

connection.setDoOutput(true);

// Send request

DataOutputStream wr = new DataOutputStream(

connection.getOutputStream());

wr.writeBytes(params);

wr.close();

// Get Response

InputStream is = connection.getInputStream();


BufferedReader rd = new BufferedReader(new InputStreamReader(is));

StringBuilder response = new StringBuilder(); // or StringBuffer if Java version 5+

String line;

while ((line = rd.readLine()) != null) {

response.append(line);

response.append('\r');

}

resultat = response.toString();

rd.close();

return response.toString();

} catch (Exception e) {

e.printStackTrace();

} finally {

if (connection != null) {

connection.disconnect();

}

}

return resultat;

}

## 6 IMPLÉMENTATION DE L'APPLICATION (DOUANIER)

## 6.1 PARTIE SERVLET SUR SERVEUR TOMCAT COMMUN

Ce douanier nous permet de faire la connexion entre le client et les états major. Le client fait les appels

vers le servlet via Ajax. Sur le servlet on va commencer par vérifier le type d’action demandé. En

fonction de l’action demandé, le bon état-major sera appelé. Voici le code qui se trouve sur le douanier

dans le servlet :

protected void processRequest(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
HttpSession session = request.getSession();
session.setMaxInactiveInterval( 60 * 60 );
response.setContentType("text/html");
response.setHeader("Access-Control-Allow-Origin", "*");

// see if any cookies are set
PrintWriter out = response.getWriter();
URLConnection connection = null;
String urlSpotify;
String client_id;
String client_secret;
String access_token;
String username;
String password;
String device_id;
String action;
String json;
try {
URL url = null;
if (request.getParameter("action").equals("chargerChart")) {
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor2/webresources/gestionSpotify/chargerChart/");
connection = url.openConnection();
BufferedReader in = new BufferedReader(new
InputStreamReader(connection.getInputStream()));
String inputLine;


StringBuilder result = new StringBuilder();
while ((inputLine = in.readLine()) != null) {
result.append(inputLine);
}
Wrk wrk = new Wrk();
wrk.sendMessage(result.toString(), out);
in.close();
} else {
switch (request.getParameter("action")) {
case "connect":
username = request.getParameter("usernameSignIN").toString();
password = request.getParameter("passwordSignIN").toString();
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor1/webresources/gestionUtilisateur/connexion/"
+ username + "/" + password);
callEtatMajorConnexion(url, response, session, out);
break;
case "signUp":
username = request.getParameter("usernameSignUP").toString();
password = request.getParameter("passwordSignUP").toString();
String repeatPass = request.getParameter("passRepeat").toString();
String clientID = request.getParameter("clientID").toString();
String clientSecret = request.getParameter("clientSecret").toString();
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor1/webresources/gestionUtilisateur/signUp/"
+ username + "/" + password + "/" + clientID + "/" + clientSecret);
if (password.equals(repeatPass)) {
callEtatMajorConnexion(url, response, session, out);
}
break;
case "getCallApi":
urlSpotify = request.getParameter("url");
access_token = request.getParameter("access_token");
device_id = request.getParameter("device_id").toString();
action = request.getParameter("action").toString();
String q = request.getParameter("q").toString();
String type = request.getParameter("type").toString();
String limit = request.getParameter("limit").toString();
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor2/webresources/gestionSpotify/getCallApi?access_token="
+ access_token + "&url=" + urlSpotify + "&device_id=" + device_id
+ "&action=" + action + "&q=" + q + "&type=" + type + "&limit=" +
limit);
callEtatMajor(url, out);
break;
case "putCallApi":
access_token = request.getParameter("access_token").toString();
urlSpotify = request.getParameter("url").toString();
device_id = request.getParameter("device_id").toString();
action = request.getParameter("action").toString();
json = request.getParameter("json").toString();
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor2/webresources/gestionSpotify/putCallApi?access_token="
+ access_token + "&url=" + urlSpotify + "&device_id=" + device_id
+ "&action=" + action + "&json=" + json);
callEtatMajor(url, out);
break;
case "postCallApi":
urlSpotify = request.getParameter("uri").toString();
access_token = request.getParameter("access_token").toString();
device_id = request.getParameter("device_id").toString();
action = request.getParameter("action").toString();
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor2/webresources/gestionSpotify/postCallApi?access_token="
+ access_token + "&device_id=" + device_id + "&action=" + action +
"&uri="
+ urlSpotify);
callEtatMajor(url, out);
break;


case "callAuthorizationApi":
client_id = request.getParameter("client_id").toString();
client_secret = request.getParameter("client_secret").toString();
urlSpotify = request.getParameter("url").toString();
String code = request.getParameter("code").toString();
String redirect_uri = request.getParameter("redirect_uri").toString();
url = new URL(
"https://carmanj.emf-
informatique.ch/javaEtatMajor2/webresources/gestionSpotify/callAuthorizationApi?url="
+ urlSpotify + "&client_id=" + client_id + "&client_secret="
+ client_secret + "&code=" + code + "&redirect_uri=" +
redirect_uri);
callEtatMajor(url, out);
break;
}
}
} catch (Exception e) {
e.printStackTrace();
}

### }

Nous avons décidé de faire une méthode qui permet d _’appeler l’api et_ retourner les infos au client.

public void callEtatMajor(URL url, PrintWriter out) {
try {
URLConnection connection = url.openConnection();
BufferedReader in = new BufferedReader(new
InputStreamReader(connection.getInputStream()));
String inputLine;
StringBuilder result = new StringBuilder();
while ((inputLine = in.readLine()) != null) {
result.append(inputLine);
}
Wrk wrk = new Wrk();
wrk.sendMessage(result.toString(), out);
in.close();
} catch (Exception e) {
e.printStackTrace();
}

### }

Nous avons aussi fait un pour la connexion. Mais nous avons rencontré un problème au niveau json

donc ça ne fonctionne pas_. Je l’ai mis pour_ montrer comment ça devrait marcher en théorie.

public void callEtatMajorConnexion(URL url, HttpServletResponse response, HttpSession session,
PrintWriter out) {
try {
URLConnection connection = url.openConnection();
BufferedReader in = new BufferedReader(new
InputStreamReader(connection.getInputStream()));
String inputLine;
StringBuilder result = new StringBuilder();
while ((inputLine = in.readLine()) != null) {
result.append(inputLine);
}
// JSONObject json = new JSONObject(result.toString());
// if (json.getString("result").equals("true")) {
// session.setAttribute("username", json.getString("username"));
// session.setAttribute("client_id", json.getString("client_id"));
// session.setAttribute("client_secret", json.getString("client_secret"));
// }
response.sendRedirect("https://carmanj.emf-
informatique.ch/javaClientConnexion/accueil.jsp");
// }
in.close();
} catch (Exception e) {
e.printStackTrace();
}


## 7 IMPLÉMENTATION DES APPLICATIONS (REST)

## 7.1 PARTIES REST ET JDBC MYSQL SUR COMPTE TIZOO DE CHACUN

## 7.1.1 PARTIE CONNEXION ET INSCRIPTION

Pour cette partie rest, j’ai le fichier rest et un Worker qui gère la connexion avec la base de données.

7.1.1.1 REST

Sur mon rest j’ai deux méthodes :

La Première permet la connexion au compte :

### @GET

@Path("connexion/{username}/{pass}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
public String getConnexion(@PathParam("username") String username,
@PathParam("pass") String pass) {
ArrayList result = wrk.checkConnexion(username, pass);
JSONObject json = null;
if (result.size() > 1 ) {
json = new JSONObject("{'response': '" + result.get( 0 ) + "', 'username': '" + username + "'
, 'clientID': '" + result.get( 1 ) + "' , 'clientSecret': '" + result.get( 2 ) + "'}");
} else {
json = new JSONObject("{'response': '" + result.get( 0 ) + "' , 'username': '" + username + "'
}");
}

return json.toString();
}

Le deuxième permet l’inscription d’un nouveau compte :

### @GET

@Path("signUp/{username}/{pass}/{clientID}/{clientSecret}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
public String postSignUp(@PathParam("username") String username,
@PathParam("pass") String pass,
@PathParam("clientID") String clientID,
@PathParam("clientSecret") String clientSecret
) {
boolean result = wrk.ajouterMembre(username, pass, clientID, clientSecret);
JSONObject json = new JSONObject("{'response' :" + result + ", 'username' :" + username + " ,
'clientID' :" + clientID + " , 'clientSecret' :" + clientSecret + "}");
return json.toString();
}

7.1.1.2 Worker

Voici les méthodes que j’ai utilisé :

CheckConnexion va vérifier si _l’utilisateur a le doit de se connecter._

public ArrayList checkConnexion(String login, String password) {
//On prépare nos variables.
PreparedStatement preparedStatement = null;
ResultSet rs = null;
ArrayList<String> result = new ArrayList<>();
//On essaie de se connecter à la base de données.
if (dbConnect()) {
try {
preparedStatement = jdbcConnection.prepareStatement("SELECT * FROM t_utilisateurs WHERE
login=?");
preparedStatement.setString( 1 , login);


rs = preparedStatement.executeQuery();
if (rs.first()) {
if (rs.getString("password").equals(password)) {
result.add("true");
result.add(rs.getString("clientID"));
result.add(rs.getString("clientSecret"));
} else {
result.add("false");
}
}
} catch (SQLException ex) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, ex);
result.add(ex.getMessage());
} //On repasse les variables pour vérifier que tout est bien fermé.
finally {
dbDisconnect();
try {
if (rs != null) {
rs.close();
rs = null;
}
} catch (SQLException ex) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, ex);
}
}
}else{
result.add("No connexion to DB");
}
return result;
}

dbConnect fait la connexion a la base de donnée.

private boolean dbConnect() {
boolean ok = false;
try {
if (jdbcConnection == null) {
//On spécifie que notre driver est JDBC
Class.forName("com.mysql.jdbc.Driver");
//L'URL se compose de l'adresse de notre base de données, ainsi que
//la base de données à utiliser.
String url = "jdbc:mysql://carmanj.emf-informatique.ch:3306/carmanj_133-sqldb";
//On essaie de se connecter à notre URL à partir d'un identifiant.
//Ici, le nom d'utilisateur est "root", et il n'y a pas de mot de passe.
//Si la connexion est réussie, la méthode "getConnection" renverra "true".
jdbcConnection = DriverManager.getConnection(url, "carmanj", "Password");
ok = true;
}
} catch (SQLException b) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, b);
} catch (ClassNotFoundException ex) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, ex);
}
//Si la connexion s'est bien passée, on renvoie "true", sinon "false".
return ok;
}

AjouterMembre va ajouter un utilisateur a la base de donnée.

public boolean ajouterMembre(String username, String pass, String clientID, String clientSecret) {
//On initialise nos variables.
boolean ok = false;
PreparedStatement prestmt = null;
ResultSet rs = null;
//On essaie d'effectuer une connexion à la base de données.
if (dbConnect()) {
try {
//On crée une requête préparée. Notre argument est remplacé par "?".
String sql = "INSERT INTO t_utilisateurs (login, password, clientID, clientSecret) values
(?, ?, ?, ?)";
//On essaie notre requête préparée si elle est valide et fonctionnelle.
if ((prestmt = jdbcConnection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS))
!= null) {
//On insère notre argument dans la requête.


prestmt.setString( 1 , username);
prestmt.setString( 2 , pass);
prestmt.setString( 3 , clientID);
prestmt.setString( 4 , clientSecret);
prestmt.executeUpdate();
//Si tout se passe bien, alors notre requête génère des clefs. C'est grâce
//à ceci que l'on sait si quelque chose a été inséré!
if ((rs = prestmt.getGeneratedKeys()) != null) {
if (rs.next()) {
ok = true;
}
}
}
//On ferme le tout, pour optimiser l'application.
prestmt.close();
prestmt = null;
rs.close();
rs = null;
} catch (SQLException ex) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, ex);
} //On vérifie à nouveau si tout est bien fermé.
finally {
dbDisconnect();
try {
if (rs != null) {
rs.close();
rs = null;
}
} catch (SQLException ex) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, ex);
}
try {
if (prestmt != null) {
prestmt.close();
prestmt = null;
}
} catch (SQLException ex) {
Logger.getLogger(Wrk.class.getName()).log(Level.SEVERE, null, ex);
}
}
}
return ok;
}

7.1.1.3 MySql et base de données

Entre ce qu’on a prévu dans la conception et ce qu’on a implémenté il y a quelques différences. En

commençant à coder nous avons réalisé que nous avons aussi besoin d’un client secret et client id de

l’utilisateur. Donc nous avons décidé de rajouter deux colonnes dans la base de donné.

## 7.1.2 PARTIE SPOTIFY

Pour la partie du client Spotify, le rest est composé de plusieurs méthode :

public String chargerChart() {}

public String callAuthorizationApi(@QueryParam("url") String url, @QueryParam("client_id") String client_id,

@QueryParam("client_secret") String client_secret, @QueryParam("redirect_uri") String redirect_uri,


@QueryParam("code") String code) {}

public String getCallApi(@QueryParam("action") String action,

@QueryParam("access_token") String access_token, @QueryParam("url") String url, @QueryParam("q")

String q,

@QueryParam("type") String type, @QueryParam("limit") String limit) {}

public String postCallApi(@QueryParam("access_token") String access_token, @QueryParam("action") String

action,

@QueryParam("device_id") String device_id, @QueryParam("uri") String uri) {}

public String putCallApi(@QueryParam("access_token") String access_token, @QueryParam("action") String

action,

@QueryParam("device_id") String device_id, @QueryParam("json") String json, @QueryParam("url")

String url) {}

Chaque une de c’est méthode va faire un appel à l’api de Spotify pour effectuer la requête demandée.

La méthode va former une url en fonction du type d’action qu’il reçoit. Voici un exemple pour cet

action.

String resultat = "error";

String params = "";

HttpURLConnection connection = null;

try {

// Create connection new URL(urlSpotify)

URL urlSpotify = null;

switch (action) {

case "PLAY":

urlSpotify = new URL(PLAY);

break;

case "NEXT":

urlSpotify = new URL(NEXT);

params = "device_id=" + device_id;

break;

case "PREVIOUS":

urlSpotify = new URL(PREVIOUS);

params = "device_id=" + device_id;

break;

case "PLAYER":

urlSpotify = new URL(PLAYER);

params = "device_id=" + device_id;

break;

case "PLAYBACKQUEUE":

urlSpotify = new URL(PLAYBACKQUEUE);


params = "uri" + uri + "&device_id=" + device_id;

break;

### }

connection = (HttpURLConnection) urlSpotify.openConnection();

connection.setRequestMethod("POST");

connection.setRequestProperty("Content-Type",

"application/x-www-form-urlencoded");

connection.setRequestProperty("Authorization", "Bearer " + access_token);

connection.setUseCaches(false);

connection.setDoOutput(true);

// Send request

DataOutputStream wr = new DataOutputStream(

connection.getOutputStream());

wr.writeBytes(params);

wr.close();

// Get Response

InputStream is = connection.getInputStream();

BufferedReader rd = new BufferedReader(new InputStreamReader(is));

StringBuilder response = new StringBuilder(); // or StringBuffer if Java version 5+

String line;

while ((line = rd.readLine()) != null) {

response.append(line);

response.append('\r');

}

resultat = response.toString();

rd.close();

return response.toString();

} catch (Exception e) {

e.printStackTrace();

} finally {

if (connection != null) {

connection.disconnect();

}

}

return resultat;

## 8 HÉBERGEMENT

Tous l'hébergement de ce projet c'est fait sur le compte Tizoo de Joel vu que le serveur Tomcat ne

fonctionnait pas sur le compte de Danilo. Les différentes parties on chaque un été posé sous le format

.war. Voici les liens vers les différentes parties du projet :

- Client – https://carmanj.emf-informatique.ch/javaClientConnexion/
- Douanier (Servlet) – https://carmanj.emf-informatique.ch/javaDouanier/
- Etat-major 1 – https://carmanj.emf-informatique.ch/javaEtatMajor1/


- Etat-major 2 – https://carmanj.emf-informatique.ch/javaEtatMajor2/

Pour faire les upload de notre projet nous avons surtout utiliser Filezilla qui permet d'accéder en FTP

au Tizoo.

## 9 INSTALLATION DU PROJET COMPLET AVEC LES 5 APPLICATIONS

Pour ce faire, nous avons déposé nos fichiers .war des 5 applications à la racine du public_html du

serveur de Joel Carman car le serveur Tizoo de Danilo Anzile n’arrivait pas à compiler les .war.

## 10 OUTILS, LANGAGES

## 10.1 OUTILS

Pour réaliser ce projet nous avons utilisé beaucoup de différent élément. Voici une liste des application

et service :

- Server tomcat 8.5.78
- NetBeans IDE 12.5 et 13
- Visual Studio code
- Cpanel
- FileZilla

## 10.2 LANGAGES..........................................................................................................................

Pour réaliser ce projet nous avons utilisé :

- MySQL
- Java
- JSP
- JavaScript
- HTML
- CSS

## 11 AUTO-ÉVALUATIONS ET CONCLUSIONS

Anzile Danilo :

C’est intéressant de voir d’autre façon de développer un site web. Même si je trouve que la

technologie utilisée est moins bien que les langages courant comme le JS/PHP et leurs frameworks

c’est bien de savoir qu’il y a d’autre technologie que peuvent être utilisé dans certaines situations.

Carman Joel :

Durant ce module j'ai pu beaucoup apprendre sur l'utilisation et le fonctionnement des JSP. J'ai trouvé

intéressent de voir une autre manière de faire un site internet autre que html, JS et PHP. Pour finir je

n'ai pas beaucoup apprécié ce langage car je trouve que c'est trop compliquer à mettre en place pour

aucune amélioration au niveaux sécurité ou utilitaire.


## 12 TESTS TECHNOLOGIQUES SELON LES EXERCICES

## 12.1.1 EXERCICE

Dans l’exercice 1 nous avons créé la première page jsp. Ensuite nous avons créé un autre index.html

pour voir le quelle des index est prioritaire. J’ai déduit que l’index html est prioritaire sur le jsp.

### <%--

Document : index.jsp

Created on : 21 mars 2022 , 09 : 07 : 41
Author : CarmanJ
--%>

<%@page contentType="text/html" pageEncoding="UTF-8"%>

<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>

</head>
<body>
<h1>Hello World! (JSP - INDEX)</h1>
</body>
</html>

## 12.1.2 EXERCICE

Dans cet exercice nous avons besoin de 3 fichiers :

12.1.2.1 Index.html

Dans ce fichier nous allons faire la page de login. Voici le code :

<html>

<head>
<title>Login Html et check Jsp</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
<h1>Page de login</h1><br>
<form method="post" action="checkLogin.jsp">
<label for="text">Votre login : </label>


<input type="text" name="username" id="user" size="50" maxlength="50"

/> <br>
<label for="text">Votre password : </label>
<input type="password" name="password" id="pass" size="50"
maxlength="50" /><br>
<input type="submit" value="Log in" >

</form>
</body>
</html>

Voici le résultat sur mon site :

12.1.2.2 checkLogin.jsp

Dans le fichier jsp nous allons reprendre les informations de la page de login pour les afficher sur la

page jsp. Nous allons aussi aller chercher des informations dans un fichier java pour la date actuelle.

<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@page import="emf.wrk.WrkDate"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>
</head>
<body>
<h1>JSP de contrôle du login</h1>
<% WrkDate wrkDate = new WrkDate("dd-MM-yyyy hh:mm:ss");
String laDate = wrkDate.donneDateCourante();%>
<p>La date du serveur est <%=laDate%></p><br>
<% String username = request.getParameter("username");
String password = request.getParameter("password");
%>
<p>Votre username est : <%=username%> <br>
Votre password est : <%=password%> <br>
</p>
</body>
</html>

Le plus important dans ce code est comment on appelle un fichier java :

<%@page import="emf.wrk.WrkDate"%>

Voici ce que ça donne :


12.1.2.3 WrkDate.java

Dans ce fichier il faut juste coder en java. Voici le code :

package emf.wrk;

import java.text.SimpleDateFormat;
import java.util.Date;

### /**

### *

* @author CarmanJ
*/
public class WrkDate {
private SimpleDateFormat date;

public WrkDate(String string) {
this.date = new SimpleDateFormat(string);
}

public String donneDateCourante(){

return date.format(new Date());
}
}

12.1.3 Exercice 3

Pour cet exercice nous avons dû aller chercher des informations depuis une api de météo. Avant de

pouvoir utiliser des objet JSON, j’ai dû installer la librairie. Il ne faut surtout pas oublier de faire les

imports depuis la librairie. Voici le code qui va permettre d’appeler l’api et d’afficher les informations

reçues sur l’interface. Pour tester : Lien d'hébergement

### <%--

Document : index
Created on : 21 mars 2022 , 10 : 45 : 35
Author : CarmanJ
--%>

<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@ page import="javax.xml.parsers.DocumentBuilderFactory" %>
<%@ page import="org.w3c.dom.Document" %>
<%@ page import="org.w3c.dom.NodeList" %>
<%@ page import="org.xml.sax.InputSource" %>
<%@ page import="org.json.JSONObject" %>
<%@ page import="java.io.*" %>
<%@ page import="java.net.*" %>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>


</head>
<body>
<h1>La météo depuis une API avec du JSON - Exerice 3 </h1>
<br>
<% String city = "corpataux";
URLConnection con = null;
try {
URL url = new URL("https://prevision-meteo.ch/services/json/" + city);
con = url.openConnection();
BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
String inputLine;
String result = "";
while ((inputLine = in.readLine()) != null) {
result += inputLine;
}
in.close();
JSONObject results = new JSONObject(result.toString());
JSONObject city_info = results.getJSONObject("city_info");
out.println("Sunrise: " + city_info.getString("sunrise") + "h<br>");
out.println("Sunset: " + city_info.getString("sunset") + "h<br>");
out.println("Elevation: " + city_info.getString("elevation") + " masl.<hr>");
JSONObject current = results.getJSONObject("current_condition");
out.println("<table><thead>Temperature</td><td>Wind Speed</td></thead>");
out.println("<tbody><tr>" + current.getInt("tmp") + "°C</td><td>"
+ current.getInt("wnd_spd") + "km/h</td></td></tbody></table>");
} catch (Exception e) {
e.printStackTrace();
out.println("<h2>Error while reading weather of " + city + "!</h2>");
}%>
<br>
<a href="https://www.prevision-meteo.ch/meteo/localite/<%=city%>">
<img src="https://prevision-meteo.ch/uploads/widget/<%=city%>_0.png" width="650"
height="250" />
</a>
</body>
</html>

Voici ce qui s’afficher sur l’interface :

## 12.1.4 EXERCICE 4 – JDBC

Dans cet exercice j'ai utilisé pour la première fois le JBDC. C'est une mise en place assez simple car il

y avait qu'un index.jsp et un Worker.java. Pour tester : Lien d'hébergement


12.1.4.1 Index.jsp

Dans ce fichier il suffit d'afficher les résultats qu’on reçoit du Worker. Tous ce code on l'as déjà vue

dans d'autre exercices.

<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@page import="emf.wrk.DbWorker"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>
</head>
<body>
<%DbWorker db = new DbWorker();
String list = db.readClass();
String listMatch = db.readMatch();%>
<h1>Ma première requête SQL</h1>

<p>Les classes sont : <br><br><%=list%></p>
<br>
<p>Les classes sont : <br><br><%=listMatch%></p>
</body>
</html>

12.1.4.2 DBWorker.java

Dans ce fichier il y a l'appelle d'une base de données depuis java. C'est un chose qu'on avait déjà vue

au module 223. Mais je vais quand même mettre le code pour un petit rappel.

Voici le code pour lire dans la base de données :

public String readMatch() {
String listClass = "";
if (connected) {
try {
Statement st = conn.createStatement();
ResultSet rs = st.executeQuery("select * from t_match");
while (rs.next()) {
String pk = rs.getString("pk_match");
String date = rs.getString("date_match");
String heure = rs.getString("heure_match");
listClass += pk + " " + date + " " + heure + "<br>";
}
} catch (SQLException | java.lang.NullPointerException ex) {

}
}

return listClass;
}

Et voici comment ouvrir la connexion a la base de donnée.

private boolean open() {
boolean ok = false;
String piloteODBCPathDb = "jdbc:mysql://lien:3306/carmanj_tournois_main" +
"?zeroDateTimeBehavior=convertToNull";
try {
Class.forName("com.mysql.jdbc.Driver");
conn = DriverManager.getConnection(piloteODBCPathDb, "carmanj", "MotDePasse");
ok = true;
} catch (SQLException e) {
System.out.println(e.getMessage());
} catch (ClassNotFoundException e) {
System.out.println(e.getMessage());
} catch (Exception e) {
System.out.println(e.getMessage());


### }

return ok;
}

## 12.1.5 EXERCICE 5 – BEAN

Dans cet exercice nous allons commencer à utiliser les Beans. Ici est où on va commencer à

compliquer les choses car il y aura besoin de 4 pages web et un Bean.java.

Pour tester : Lien d'hébergement

Il y a que deux page qui valent vraiment la peine. C'est la page de traitement de la connexion et de

l'affichage d'un bean. Voici la première:

<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@page import="ch.emf.wrk.BeanInfo"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>
</head>
<body>
<jsp:useBean id="info" scope="session" class="ch.emf.wrk.BeanInfo"/>
<% String username = request.getParameter("username");
String password = request.getParameter("password");
if ((username.equals("carmanj")) && (password.equals("emf"))) {
info.setName("Carman");
info.setPrenom("Joel");
info.setAge( 18 );
response.sendRedirect("maJspLog.jsp");
} else {
response.sendRedirect("erreur.html");
}
%>
</body>
</html>

Sur cette page il y a la première utilisation de d'un bean. Avec cette ligne nous allons "créer" une

variable info qui pourra être utiliser dans toute la session :

<jsp:useBean id="info" scope="session" class="ch.emf.wrk.BeanInfo"/>

Qui veux dire que quand on va aller vers la page d'affichage (si la connexion à réussit) on pourra

accéder à cette "objet"(info) dont on attribuer des valeurs. Voici la page :

<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@page import="ch.emf.wrk.BeanInfo"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>
</head>
<body>
<jsp:useBean id="info" scope="session" class="ch.emf.wrk.BeanInfo"/>
<h1>Connecté</h1>
<br><br>
<p>Nom : <%=info.getName()%></p>
<p>Prénom : <%=info.getPrenom()%></p>
<p>Age : <%=info.getAge()%></p>
</body>
</html>


## 12.1.6 EXERCICE 6 – SERVLET SIMPLE

Le but de cet exercice était de créer notre premier servlet. C'est un processus très simple.

1. Pour commencer on va créer un package :
2. Ensuite nous allons créer le servlet à l'intérieur du package.

Ici il faut donner le nom de notre servlet et le package.


```
Là nous avons aussi la possibilité de changer le nom du servlet ou l'url qui sera utiliser pour y
accéder.
```
3. Avant de continuer nous allons mettre en place une page de login en jsp. Voici le contenu de

la page :

### <%--

Document : index
Created on : 28 mars 2022 , 08 : 48 : 35
Author : CarmanJ
--%>

<%@page contentType="text/html" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSP Page</title>
</head>
<body>
<h1>Page de login</h1><br>
<form method="post" action="/javaServletSimple/MaServlet">
<label for="text">Votre login : </label>
<input type="text" name="login" id="user" size="50" maxlength="50" /> <br>
<label for="text">Votre password : </label>
<input type="password" name="password" id="pass" size="50" maxlength="50" /><br>
<input type="submit" value="Log in" >
</form>
</body>
</html>

4. Maintenant que notre servlet et notre page de login sont créés nous allons écrire quelque ligne

```
qui permettront d'afficher le login et mot de passe utiliser pour la connexion. Voici les ligne
importante pour afficher le mot de passe et login :
```
out.println("<h1>Servlet MaServlet at " + request.getContextPath() + "</h1>");
out.println("<br>");
out.println("<p>Votre login est : " + request.getParameter("login") + "<br> Votre password est : " +
request.getParameter("password"));

5. Pour finir il faut tester si ce qu’on a fait marcher. Voici un lien de test : LE LIEN


## 12.1.7 EXERCICE 7 – JSP-SERVLET-SESSION

Le but de cet exercice est de mettre en lien les servlets qu’on a vu dans l'exercice précédent et de

rajouter la gestion de session. Pour ce faire nous avons créer 3 pages jsp ainsi que 2 Bean et un

Servlet. Voici le diagramme qui nous a été fournis avec l'exercice :

12.1.7.1 Index.jsp

Il n'y a rien qui change dans cette page que dans l’exercice précédent.

12.1.7.2 DouaneServlet

Cette fois le servlet n'a rien à afficher à l'écran mais il doit gérer les connexions et les sessions. Il y a

quelque ligne très importante dans ce servlet. Les voici

Récupération de la session et initialisation de la duré de la session. (20sec)

HttpSession session = request.getSession(); // accède à la session
session.setMaxInactiveInterval( 20 );

Initialisation d'un Bean et l'insertion des données dans le Bean

BeanErreur erreur = new BeanErreur();
erreur.setContexte("JspServletSessionJsp");
erreur.setSource("Douane Servelet");
erreur.setErreur(response.toString());
BeanInfo info = new BeanInfo();
info.setLocalite("Corpataux");
info.setNom("Carman");
info.setPrenom("Joel");
info.setRoute("Route du centre 81");

Vérification du login et password ainsi que l'ajout de l'objet à la session.

String login = request.getParameter("login");
String password = request.getParameter("password");
if (login.equals("carmanj") && password.equals("emf")) {


session.setAttribute("info", info); // place le bean Erreur erreur dans la session
response.sendRedirect("pageAutorise.jsp"); //redirection de la page
} else {
session.setAttribute("erreur", erreur); // place le bean Erreur erreur dans la session
response.sendRedirect("erreur.jsp"); //redirection de la page
}

12.1.7.3 Page autorise et erreur

Pour la documentation je vais combiner ses deux pages car elles sont pareil. La seule différence est

qu'un page utiliser le Bean erreur et l’autre info. Voici les parties très importantes :

Vérifier si l'utilisateur est connecté en récupérant l'attribut

if (session != null) {
BeanInfo info = (BeanInfo) session.getAttribute("info");
if (info != null) {
nom = info.getNom();
prenom = info.getPrenom();
route = info.getRoute();
localite = info.getLocalite();
}else{
response.sendRedirect("index.jsp");
}

### }

Afficher les résultats

<p>Nom : <%=nom%></p>
<p>Prénom : <%=prenom%></p>
<p>Route : <%=route%></p>
<p>Localité : <%=localite%></p>


