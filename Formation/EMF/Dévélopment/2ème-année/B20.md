# B20 – Élaborer des bases de

# données et les traiter avec SQL.

## Rapport personnel

```
Version 2 du 24 janvier 2021
```
## Danilo Anzile

```
Module du 02 .0 9 .2020 au 01 .10. 2020
```

## B20 – Élaborer des bases de données et les traiter avec SQL. - Rapport personnel



- 1 Introduction Table des matières
- 2 Rappelle
   - 2.1 Règle de nommage
- 3 Exercice « Orchestre »
   - 3.1 Mise en situation
   - 3.2 Schéma entité-relation « Orchestre »
   - 3.3 Diagramme « Orchestre »
- 4 MySQL Workbench
   - 4.1 Qu’est - ce que c’est?
   - 4.2 Patte d’oie
      - 4.2.1 Comparaison
- 5 Transfère schéma vers base de données
- 6 Exercice Lien N-N
   - 6.1 Quand faut-il utiliser une PK dans une TR
   - 6.2 (A) Diagramme patte d’oie
   - 6.3 (B) Diagramme patte d’oie
   - 6.4 (C) Diagramme patte d’oie
- 7 Exercice Les contacts d’une entreprise
   - 7.1 Schéma entité-relation..............................................................................................
   - 7.2 Schéma patte d’oie
- 8 Formes normales
   - 8.1 But
   - 8.2 Plan
   - 8.3 1NF
      - 8.3.1 Comment reconnaître une table de 1er forme.................................................
   - 8.4 2NF
      - 8.4.1 Comment reconnaître une table de 2ème forme
      - 8.4.2 Exemple
   - 8.5 3NF
      - 8.5.1 Comment reconnaître une table de 3ème forme
      - 8.5.2 Exemple
   - 8.6 Liens utiles
- 9 Les relations 1 à
- 10 Les relations hiérarchiques
- 11 Les contraintes d’intégrité
   - 11.1 Les règles de suppression
      - 11.1.1 Restrict
      - 11.1.2 Cascade
      - 11.1.3 Set NULL
- 12 Bonne pratique
- 13 Chapitre SQL
   - 13.1 SQL qu’est - ce que c’est
   - 13.2 Commande utile
      - 13.2.1 Select
      - 13.2.2 Where
      - 13.2.3 Group by
      - 13.2.4 Having
      - 13.2.5 SUM ()
      - 13.2.6 MIN ()
      - 13.2.7 MAX ()
      - 13.2.8 AVG ()
      - 13.2.9 Count ()
      - 13.2.10 ASC
      - 13.2.11 DESC
      - 13.2.12 Concat (Col1, Col2, ...)
      - 13.2.13 AS nomAlias
      - 13.2.14 Source
- 14 Exercice célébrité
   - 14.1 Requête
   - 14.2 Modifications de données via des commandes SQL
- 15 Les jointures
   - 15.1 Qu’est - ce que c’est?
   - 15.2 Type de jointures
      - 15.2.1 INNER JOIN
      - 15.2.2 LEFT JOIN
      - 15.2.3 LEFT JOIN (sans l’intersection de B)
      - 15.2.4 RIGHT JOIN
      - 15.2.5 RIGHT JOIN (sans l’intersection de A)
   - 15.3 Les jointures avec une table sur elle-même
- 16 Exercice célébrité 5 tables
      - 16.1.1 Schéma patte d’oie
      - 16.1.2 Requêtes
- 17 Exercice ASM
      - 17.1.1 Schéma patte d’oie
      - 17.1.2 Avant de commencer l’exercice
      - 17.1.3 Requête
- 18 Ajouter, Modifier, Supprimer
      - 18.1.1 Avant
      - 18.1.2 Insert
      - 18.1.3 Update
      - 18.1.4 Delete
- 19 Accroche Aqua splash
   - 19.1 Schém a patte d’oie
   - 19.2 Requête
- 20 Exercice Asterix
   - 20.1 Schéma pa tte d’oie
   - 20.2 Requête
      - 20.2.1 Modifications
- 21 Exercice Formatif
   - 21.1 Patte d’oie
   - 21.2 Requête
- 22 Exercice Formatif
   - 22.1 Schéma patte d’oie
   - 22.2 Requête
- 23 Conclusion
- 24 Source


## 1 Introduction

Les objectifs du module sont :
Analyser les besoins en informations et les exigences des données avec le mandataire.
Créer le modèle conceptuel de données (ERM), identifier les informations manquantes et le cas
échéant supprimer les redondances (formes normales)
Compléter le modèle conceptuel de données (attributs, clé primaire ; identification, clé étrangère,
type de données).
Transformer un modèle de données (ERM) en un design de base de données relationnelle et implé-
menter le schéma de base de données dans un SGBDR
Charger la base de données avec des données de test au moyen d’un utilitaire ou de commandes
SQL.
Exécuter des commandes SQL (Create-Read-Update-Delete) visant le traitement et l'exploitation de
la base de données.

## 2 Rappelle 104

### 2.1 Règle de nommage

- T_ → Table
- TR_ → Table de relation
- Pas d’accent
- PK_ → Clé primaire
- FK_ → Clé étrangère

## 3 Exercice « Orchestre »

### 3.1 Mise en situation

Pour reprendre en main les schémas d’entité et relation ainsi que prendre en main Mysql Work-
bench, nous avons commencé par faire un exercice par rapport à l’orchestre

### 3.2 Schéma entité-relation « Orchestre »


### 3.3 Diagramme « Orchestre »

## 4 MySQL Workbench

### 4.1 Qu’est - ce que c’est?

Cet outil nous permet de crée des bases de données. Il remplace Access car il nous permet de
faire plus de choses que Access.


### 4.2 Patte d’oie

La patte d’oie correspond au lien qui se forme lorsque nous relions les tables entres elles.

#### 4.2.1 Comparaison

Voilà pourquoi on appelle ce schéma « patte d’oie ».

## 5 Transfère schéma vers base de données

```
Il suffit de cliquer sur l’onglet « Database » puis choisir « Forward Engineer ».
```
```
Se connecter à sa base de données, dans ce cas la base de données est en local alors nous
pouvons mettre l’adresse ip : 127.0.0.1 sur le port 3306
```
```
Next
```

```
Next
```
```
Ensuite il faut regarder dans le code et supprimer tous les « VISIBLE ». Nous devons faire ça à
cause d’un problème de compatibilité.
```
## 6 Exercice Lien N-N

### 6.1 Quand faut-il utiliser une PK dans une TR

Quand on souhaite que les données inscrit dans la table de relation soient unique, on leur af-
fecte une clé primaire ce qui permet d’éviter les doublons et former des couples.


### 6.2 (A) Diagramme patte d’oie

### 6.3 (B) Diagramme patte d’oie


### 6.4 (C) Diagramme patte d’oie

## 7 Exercice Les contacts d’une entreprise

### 7.1 Schéma entité-relation..............................................................................................

### 7.2 Schéma patte d’oie


## 8 Formes normales

### 8.1 But

La normalisation permet d’éliminer les redondances de données. Il nous procure un gain de
place ainsi qu’il nous élimine les anomalies du au mise à jour comme l’insertion et l’effacement.

### 8.2 Plan

- 1NF (Première forme normale)
- 2NF (Deuxième forme normale)
- 3NF (Troisième forme normale)

### 8.3 1NF


On peut voir que le Nom et le Prénom ont été séparer dans deux cellules différentes ainsi que
l’adresse a été sous diviser en 3 cellules.

Les attributs doivent être constants dans le temps.

#### 8.3.1 Comment reconnaître une table de 1er forme.................................................

### 8.4 2NF

#### 8.4.1 Comment reconnaître une table de 2ème forme


#### 8.4.2 Exemple

### 8.5 3NF

#### 8.5.1 Comment reconnaître une table de 3ème forme

#### 8.5.2 Exemple

### 8.6 Liens utiles

Wikipédia

## 9 Les relations 1 à

Les relations 1 à 1 sont utilisé si par exemple on voudra isoler les identifiant ainsi que le mot de
passé d’un utilisateur. Dans ce cas nous créons une table à part avec un lien 1 à 1 entre la
table login et utilisateur.


## 10 Les relations hiérarchiques

Le lien hiérarchique permette de connaitre un arbre de qui est supérieur a qui comme dans
l’exemple si dessous, ou encore de connaitre un arbre généalogique si l’on stocke les enfants
et parents.

L’une des règles les plus importante pour ce type de relations, c’est que les FK doivent absolu-
ment accepter le NULL. Si l’on n’accepte pas les NULL, sa serra impossible d’insère des don-
nées vues que le premier n’aura pas de personne au-dessus de lui.

## 11 Les contraintes d’intégrité

Les contraintes d’intégrité permettent de rendre des données uniques. Par exemple on peut co-
cher la casse « UNIQUE » ce qui permet de ne pas avoir en double un canton qui a le même
nom. Exemple, il ne peut pas y avoir deux fois « Fribourg » dans une même table.


On peut créer des indexes de type unique. Il permet de ne pas avoir de doublons dans « un
couple ». Dans l’exemple si dessous, on rend unique le nom d’une école par canton (il peut y
avoir deux fois le même nom d’école mais pas dans le même canton).

### 11.1 Les règles de suppression

En ajoutant des règles de suppression, on peut sécuriser notre base de données pour qu’il n’y a
pas tout qui se supprime si on supprime un champ ou vice versa supprimer tous les champs à
partir d’une suppression
Pour ce faire il faut aller dans la partie « Foreign Keys » de la table. Puis on choisit le type de
suppression.


#### 11.1.1 Restrict

Il ne supprime pas la table parent tant qu’elle a des enfants. Par exemple, on ne peut pas sup-
primer un canton tant qu’il a des écoles à l’intérieur.

#### 11.1.2 Cascade

Il supprime tous les enfants de la table parent que l’on veut supprimer. Par exemple, si on veut
supprimer une école, toutes les classes qui s’y trouvent vont être supprimé avec.

#### 11.1.3 Set NULL

Cette option est disponible uniquement si la fk n’est pas obligatoire.

## 12 Bonne pratique

Le prix doit obligatoirement être en décimal. Le float ou le double peut être utilisé pour le poids
d’une personne ou sa taille mais pas pour un prix car ça peut créer des différences.

## 13 Chapitre SQL

### 13.1 SQL qu’est - ce que c’est

SQL signifie Structured Query Language, c’est un langage qui permet d’exploiter des bases de
données relationnelles. Il permet de manipuler les données en les modifiants, ajoutant, suppri-
ment. Grâce à ce langage on peut aussi créer des requetés en fonction de ce que nous avons
besoins.

### 13.2 Commande utile

#### 13.2.1 Select

SELECT est une commande SQL qui permet d'extraire des données des tables d'une base de
données relationnelle. Une commande SELECT peut obtenir zéro ou plusieurs tuples provenant
de tables et de vues.

#### 13.2.2 Where

Le mot-clé WHERE permet de définir les conditions de sélection des tuples. Différentes condi-
tions peuvent être exprimées, et une équation peut ainsi être créée en reliant les différentes
conditions par les mots clefs AND ou OR. Des parenthèses sont utilisables afin de déterminer
l'ordre d'application des différentes conditions.

#### 13.2.3 Group by

La commande Group by permet de regrouper par exemple tous les pays ensemble.

#### 13.2.4 Having

C’est la même chose que where mais après un Group by.

#### 13.2.5 SUM ()

La fonction SUM permet de faire la somme d’une colonne.


#### 13.2.6 MIN ()

MIN () permet d’afficher le minimum.

#### 13.2.7 MAX ()

MAX () permet d’afficher le maximum

#### 13.2.8 AVG ()

Cette fonction permet de faire la moyenne d’une colonne.

#### 13.2.9 Count ()

La fonction Count () compte le nombre de valeur qu’il y a dans la colonne.

#### 13.2.10 ASC

En l’additionnant avec la commande ORDER BY elle permet de classer les valeurs dans l’ordre
ascendant.

#### 13.2.11 DESC

En l’additionnant avec la commande ORDER BY elle permet de classer les valeurs dans l’ordre
descendant.

#### 13.2.12 Concat (Col1, Col2, ...)

Permet de concaténer des colonnes ensembles.

#### 13.2.13 AS nomAlias

As permet de créer des alias. Ceci peut être utile si on a plusieurs fois la même table utilisée.

#### 13.2.14 Source

Wikipédia
https://moodle.polymtl.ca/pluginfile.php/16246/mod_resource/content/2/QuelquesCommandesMySQL.pdf

## 14 Exercice célébrité

### 14.1 Requête

1. Lister toutes les célébrités présentes dans la table
    **SELECT * FROM celebrite_1table.t_celebrite;**
2. Lister toutes les célébrités dans l’ordre de leur salaire.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **ORDER BY salaire_mensuel desc**
3. Lister toutes les célébrités dans l’ordre des pays et des salaires, le plus grand en premier.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **ORDER BY pays asc, salaire_mensuel desc**
4. Lister toutes les célébrités hommes du plus jeune au plus vieux
    **SELECT * FROM celebrite_1table.t_celebrite**
    **ORDER BY civilite asc, date_naissance desc**
5. Lister toutes les femmes célibataires ou tous les hommes célibataires selon
vos gouts (liste à conserver ☺).


```
SELECT * FROM celebrite_1table.t_celebrite
WHERE civilite = 'Madame'
ORDER BY civilite asc, date_naissance desc
```
6. Lister toutes les célébrités dont le nom commence par B.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **WHERE nom like 'B%' ORDER BY nom asc**
7. Rechercher les célébrités possédant un k ou un j dans leur nom.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **WHERE nom like '%k%' or nom like '%j%' ORDER BY nom asc**
8. Lister les personnes qui n’ont pas de date de naissance connue.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **WHERE date_naissance like '0000- 00 - 00'**
9. Lister les célébrités qui ont un salaire entre 30000 et 60000.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **WHERE salaire_mensuel between 30000 and 60000**
10. Lister toutes les célébrités nées dans les années cinquante et déjà décédées.
    **SELECT * FROM celebrite_1table.t_celebrite**
    **WHERE date_naissance between "1950- 01 - 01" and "1959- 12 - 31"**
    **and decede = 1**
11. Lister les messieurs qui ne viennent pas de F, USA, CH et SP
    **SELECT * FROM celebrite_1table.t_celebrite**
    **WHERE civilite ="Monsieur" and pays not in ("Suisse","Etat-**
    **Unis","France","Espagne")**
12. Compter le nombre de célébrités.
    **SELECT count(*) FROM celebrite_1table.t_celebrite**
13. Calculer le salaire moyen des célébrités.
    **SELECT AVG(salaire_mensuel) FROM celebrite_1table.t_celebrite**
14. Rechercher le plus petit et le plus gros salaire.
    **SELECT min(salaire_mensuel)"petit salaire", max(salaire_mensuel) "Gros**
    **salaire"**
    **FROM celebrite_1table.t_celebrite**
15. Compter le nombre de personnes par pays.
    **SELECT pays, Count(*) nb FROM t_celebrite**
    **Group by pays order by nb desc**
16. Compter les personnes par état civil.
    **SELECT etat_civil, count(*) nb FROM t_celebrite**
    **Groupe by etat_civile order by nb desc**
17. Calculer le salaire moyen par domaine.
    **SELECT domaine, avg(salaire_mensuel) FROM celebrite_1table.t_celebrite**
    **group by domaine**
18. Calculer le total (somme) des salaires des célébrités par année de naissance.
    **SELECT year(date_naissance) annee , sum(salaire_mensuel) FROM**
    **celebrite_1table.t_celebrite**
    **group by annee order by annee**
19. Calculer l'âge des personnes vivantes
    **SELECT nom, prenom,**
    **Year(now()) -year(date_naissance)**
    **FROM t_celebrite**
    **Where decede = 0**
20. Rechercher le jour de la semaine des dates de naissance (1=dimanche)
    **SELECT nom ,prenom , dayofweek(date_naissance)**
    **FROM celebrite_1table.t_celebrite**
21. Afficher le jour de la semaine de votre date de naissance
    **SELECT dayname(“2002- 08 - 02”)**
22. Afficher le jour de la semaine de la date courante
    **SELECT dayname(curdate())**


### 14.2 Modifications de données via des commandes SQL

1. Ajouter une célébrité (vous par exemple) avec une information pour tous les attributs.
    **Insert into t_celebrite values (134, « Monsieur », « Anzile », «Danilo » , «**
    **Acteur » , « Suisse », « Célibataire » , 0, 500000, « 2003- 10 - 27 »**
2. Effacer Edouard Balladur (une seule requête).
    **Delete from t_celebrite**
    **Where nom = « balladur » and prenom = « Edouard »**

## 15 Les jointures

### 15.1 Qu’est - ce que c’est?

Les jointures en SQL permettent d’associer plusieurs tables dans une même requête. Ce
qui permet d’exploiter la puissance des bases de données relationnelles pour obtenir des
résultats qui combinent les données de plusieurs tables.

### 15.2 Type de jointures

- **INNER JOIN** : jointure interne pour retourner les enregistrements quand la condition
    est vraie dans les 2 tables. C’est l’une des jointures les plus communes.
- **LEFT JOIN** : jointure externe pour retourner tous les enregistrements de la table de
    gauche (LEFT = gauche) même si la condition n’est pas vérifiée dans l’autre table
- **RIGHT JOIN** : jointure externe pour retourner tous les enregistrements de la table de
    droite (RIGHT = droite) même si la condition n’est pas vérifiée dans l’autre table.

#### 15.2.1 INNER JOIN

#### 15.2.2 LEFT JOIN


#### 15.2.3 LEFT JOIN (sans l’intersection de B)

#### 15.2.4 RIGHT JOIN

#### 15.2.5 RIGHT JOIN (sans l’intersection de A)


### 15.3 Les jointures avec une table sur elle-même

Affichez la liste des catégories et pour chaque catégorie, le nom de la catégorie supérieure (s’il y
en a une), il ne faut pas oublier d’accepter les null. Car s’il n’a pas de supérieur il ne pourra pas
être rajouter.

```
SELECT t_categorie.Categorie, supp.Categorie
FROM t_categorie
inner join t_categorie supp
on t_categorie.FK_Categorie_Superieure= supp.PK_Categorie
```
## 16 Exercice célébrité 5 tables

#### 16.1.1 Schéma patte d’oie


#### 16.1.2 Requêtes

1. Lister les célébrités et leur domaine
    **SELECT t_celebrite.Nom, t_celebrite.Prenom, t_domaine.Domaine FROM**
    **celebrite_5tables.t_celebrite**
    **LEFT JOIN t_domaine ON t_celebrite.FK_Domaine = t_domaine.PK_Domaine**
2. Lister toutes les femmes célibataires ou hommes célibataires selon vos goûts (liste à con-
server ☺).
    **SELECT t_celebrite.Nom, t_celebrite.Prenom, t_etatcivil.EtatCivil FROM**
    **celebrite_5tables.t_celebrite**
    **LEFT JOIN t_etatcivil ON t_celebrite.FK_EtatCivil = t_etatcivil.PK_EtatCivil**
    **WHERE t_etatcivil.EtatCivil = "Célibataire"**
3. Lister les messieurs qui ne viennent pas de F, USA, CH et SP
    **SELECT t_celebrite.Nom, t_celebrite.Prenom, t_pays.Pays FROM t_celebrite**
    **LEFT JOIN T_pays ON t_celebrite.FK_pays = T_pays.PK_Pays**
    **WHERE pays not in ("France","Etat-Unis","Suisse","Espagne")**
4. Compter le nombre de personnes par pays (pays en toutes lettres)
    **SELECT T_pays.Pays , COUNT(*) as nb FROM t_celebrite**
    **Join t_pays ON t_celebrite.FK_Pays = t_pays.PK_Pays**
    **Group by pays order by nb desc**
5. Compter les personnes par état civil.
    **SELECT t_etatcivil.EtatCivil , COUNT(*) as nb FROM t_celebrite**
    **Join t_etatcivil ON t_celebrite.FK_EtatCivil = t_etatcivil.PK_EtatCivil**
    **Group by EtatCivil order by nb desc**
6. Calculer le salaire moyen par domaine.
    **SELECT t_domaine.domaine , AVG(t_celebrite.Salaire_mensuel) FROM t_celebrite**
    **Join t_domaine ON t_celebrite.FK_Domaine = t_domaine.PK_Domaine**
    **Group by domaine**
7. Calculer le total (somme) des salaires des célébrités par pays
    **SELECT T_pays.Pays , SUM(Salaire_mensuel) as Somme_Salaire FROM t_celebrite**
    **Join t_pays ON t_celebrite.FK_Pays = t_pays.PK_Pays**
    **Group by pays order by Somme_Salaire desc**

## 17 Exercice ASM

#### 17.1.1 Schéma patte d’oie


#### 17.1.2 Avant de commencer l’exercice

Avant de commencer l’exercice il ne faut pas oublier de taper la commande :

```
set sql_mode = 'NO_ENGINE_SUBSTITUTION,ONLY_FULL_GROUP_BY';
```
#### 17.1.3 Requête

1. Affichez la liste des compositeurs triés par nom de famille
    **SELECT t_compositeur.Nom, t_compositeur.Prenom**
    **FROM bdasm.t_compositeur**
    **order by nom asc**
2. Affichez uniquement le dernier compositeur de la liste triée par nom de famille
    **SELECT t_compositeur.Nom, t_compositeur.Prenom**
    **FROM bdasm.t_compositeur**
    **order by nom desc**
    **limit 1**
3. Affichez la liste des compositeurs dont le nom contient la lettre « z ».
    **SELECT t_compositeur.Nom, t_compositeur.Prenom**
    **FROM bdasm.t_compositeur**
    **WHERE nom like '%z%'order by nom asc**
4. Affichez la liste des compositeurs dont le nom commence par « B » et finit par « L »
    **SELECT t_compositeur.Nom, t_compositeur.Prenom**
    **FROM bdasm.t_compositeur**
    **WHERE nom like 'B%'and nom like '%L' order by nom asc**


5. Affichez les titres et durées des pièces plus longues que 15 minutes
    **SELECT t_piece.Titre, t_piece.Duree**
    **FROM bdasm.t_piece**
    **WHERE duree > "00:15:00"**
    **order by titre asc**
6. Affichez le titre et la durée des trois pièces les plus longues
    **SELECT t_piece.Titre, t_piece.Duree**
    **FROM bdasm.t_piece**
    **order by duree desc**
    **limit 3**
7. Affichez les compositeurs dont le nom contient entre 10 et 13 caractères
    **SELECT t_compositeur.Nom, t_compositeur.Prenom**
    **FROM bdasm.t_compositeur**
    **WHERE LENGTH(Nom) >10 and LENGTH(Nom) <13**
8. Affichez les titres des pièces classées en 2010 ou plus longues que 15 minutes
    **SELECT t_piece.Titre, t_piece.Duree, t_piece.AnneeClassement**
    **FROM bdasm.t_piece**
    **WHERE AnneeClassement = 2010 or Duree > "00:15:00"**
9. Afficher le nombre de pièces classées en 2015
    **SELECT COUNT(t_piece.Titre), t_piece.AnneeClassement**
    **FROM bdasm.t_piece**
    **WHERE AnneeClassement = 2015**
10. Affichez la durée de chaque pièce en secondes (utilisez la fonction TIME_TO_SEC pour convertir
la durée en secondes)
    **SELECT t_piece.Titre, time_to_sec(t_piece.Duree)**
    **FROM bdasm.t_piece**
11. Affichez la durée moyenne en secondes des pièces (basez-vous sur la requête précédente)
    **SELECT AVG(time_to_sec(t_piece.Duree))**
    **FROM bdasm.t_piece**
12. Affichez la durée moyenne des pièces en format HH :MM : SS (utilisez la fonction SEC_TO_TIME
pour mettre en format votre résultat par rapport à la requête précédente)
    **SELECT SEC_TO_TIME (AVG(time_to_sec(t_piece.Duree)))**
    **FROM bdasm.t_piece**
13. Comptez le nombre de pièces de la liste qui ont un titre de plus de 45 caractères
    **SELECT COUNT(t_piece.Titre)**
    **FROM bdasm.t_piece**
    **WHERE length(t_piece.Titre) > 45**
14. Comptez le nombre de noms de familles de compositeurs différents (sans doublons)
    **SELECT COUNT(DISTINCT t_compositeur.Nom)**
    **FROM bdasm.t_compositeur**
15. Afficher les compositeurs qui ont comme nom « Andriessen », « Ball », « Baker » ou « Wright » et
qui ont un prénom composé de 5 lettres
    **SELECT t_compositeur.Nom, t_compositeur.Prenom**
    **FROM bdasm.t_compositeur**
    **WHERE nom = "Andriessen" or nom = "Ball" or nom = "Wright" or length(nom) = 5**
16. Affichez les titres et catégories des pièces
    **SELECT t_piece.Titre, t_categorie.Categorie**
    **FROM bdasm.t_piece**
    **LEFT JOIN t_categorie ON t_piece.FK_Categorie = t_categorie.PK_Categorie**
17. Affichez les titres et maisons d’édition des pièces qui sont éditées
    **SELECT t_piece.Titre, t_edition.Abreviation**
    **FROM bdasm.t_piece**
    **LEFT JOIN t_edition ON t_piece.FK_Edition = t_edition.PK_Edition**
18. Affichez les titres et maisons d’édition des pièces éditées ou non
    **SELECT t_piece.Titre, t_edition.Abreviation**
    **FROM bdasm.t_piece**
    **LEFT JOIN t_edition ON t_piece.FK_Edition = t_edition.PK_Edition**
19. Affichez les titres des pièces non éditées


```
SELECT t_piece.Titre, t_edition.Abreviation
FROM bdasm.t_piece
LEFT JOIN t_edition ON t_piece.FK_Edition = t_edition.PK_Edition
WHERE t_piece.FK_Edition is null
```
20. Affichez les titres, catégories et compositeurs des pièces classées en 2015 (triés par titre)
    **SELECT t_piece.Titre, t_categorie.Categorie, t_compositeur.Nom,**
    **t_compositeur.prenom, t_piece.AnneeClassement**
    **FROM bdasm.t_piece**
    **LEFT JOIN t_categorie ON t_piece.FK_Categorie = t_categorie.PK_Categorie**
    **LEFT JOIN t_compositeur ON t_piece.FK_Compositeur =**
    **t_compositeur.PK_Compositeur**
    **WHERE AnneeClassement = 2015**
    **order by Titre asc**
21. Affichez les titres, compositeurs et arrangeurs (s’il y en a un) des pièces
    **SELECT t_piece.Titre, Compositeur.Nom, Arrangeur.Nom**
    **FROM bdasm.t_piece**
    **Left join t_compositeur As Compositeur On t_piece.FK_compositeur =**
    **Compositeur.PK_Compositeur**
    **Left join t_compositeur As Arrangeur On t_piece.FK_Arrangeur=**
    **Arrangeur.PK_Compositeur**
22. Affichez les titres, compositeurs, arrangeurs (s’il y en a un) des pièces classées en « 1ère catégo-
rie »
    **SELECT t_piece.Titre, Compositeur.Nom, Arrangeur.Nom, t_categorie.Categorie**
    **FROM bdasm.t_piece**
    **Left join t_compositeur As Compositeur On t_piece.FK_compositeur =**
    **Compositeur.PK_Compositeur**
    **Left join t_compositeur As Arrangeur On t_piece.FK_Arrangeur=**
    **Arrangeur.PK_Compositeur**
    **Right join t_categorie On t_piece.FK_Categorie = t_categorie.PK_Categorie**
    **Where t_categorie.Categorie = "1ère catégorie"**
23. Affichez la liste des pièces (les titres uniquement) classées après 2013 en « Excellence » pour les
formations « Brass Band »
    **SELECT Titre**
    **FROM bdasm.t_piece**
    **Inner join tr_piece_formation On tr_piece_formation.FK_Piece =**
    **tr_piece_formation.FK_Formation**
    **Left join t_categorie On t_piece.FK_Categorie = t_categorie.PK_Categorie**
    **Left join t_formation on tr_piece_formation.FK_Formation =**
    **t_formation.PK_Formation**
    **Where AnneeClassement > "2013" and t_categorie.Categorie = "Excellence" and**
    **t_formation.Formation = "Brass Band"**
24. Affichez la liste des catégories et pour chaque catégorie, le nom de la catégorie supérieure (s’il y
en a une)
    **SELECT t_categorie.Categorie, Categorie_Superieur.Categorie**
    **FROM bdasm.t_categorie**
    **Left join t_categorie AS Categorie_Superieur on**
    **t_categorie.FK_Categorie_Superieure = Categorie_Superieur.PK_Categorie**
25. Affichez les maisons d’éditions qui n’ont pas de pièces classées
    **SELECT t_edition.Abreviation, t_piece.Titre**
    **FROM bdasm.t_edition**
    **left join t_piece on t_edition.PK_Edition = t_piece.FK_Edition**
    **Where t_piece.FK_Edition is null**
26. Affichez la liste (sans doublon) des maisons d’édition qui ont au moins une pièce classée en 2015
    **SELECT t_edition.Abreviation**
    **FROM bdasm.t_edition**
    **left join t_piece on t_edition.PK_Edition = t_piece.FK_Edition**
    **Where t_piece.AnneeClassement = "2015"**
    **group by t_edition.Abreviation**
27. Affichez les noms de famille de compositeurs avec le nombre de compositeurs qui ont le même
nom de famille
    **SELECT t_compositeur.Nom, Count(*) nb**
    **FROM bdasm.t_compositeur**


```
group by t_compositeur.Nom order by nb desc
```
28. Affichez les noms de famille de compositeurs avec le nombre de compositeurs qui ont le même
nom de famille uniquement pour les noms utilisé au moins par 2 compositeurs
    **SELECT t_compositeur.Nom, Count(Nom)**
    **FROM bdasm.t_compositeur**
    **group by t_compositeur.Nom**
    **having count(nom) >= 2**
29. Même requête que la précédente mais uniquement pour les compositeurs ayant un nom de plus
de 5 caractères
    **SELECT t_compositeur.Nom, Count(Nom)**
    **FROM bdasm.t_compositeur**
    **group by t_compositeur.Nom**
    **having count(nom) >= 2 and length(nom) >= 5**
30. Affichez le nombre de pièces par catégorie
    **SELECT t_categorie.Categorie, count(titre)**
    **FROM bdasm.t_piece**
    **Right join t_categorie on t_piece.FK_Categorie = t_categorie.PK_Categorie**
    **Group by t_categorie.Categorie**
31. Affichez les nombres de pièces par formation
    **SELECT t_formation.Formation, count(titre)**
    **FROM bdasm.t_piece**
    **Inner join tr_piece_formation on tr_piece_formation.FK_Piece =**
    **t_piece.PK_Piece**
    **Inner join t_formation on tr_piece_formation.FK_Formation =**
    **t_formation.PK_Formation**
    **group by t_formation.Formation**
32. Affichez les durées moyennes des pièces par catégorie (reprenez la logique TIME_TO_SEC et
SEC_TO_TIME des requêtes de la partie A)
    **SELECT t_categorie.Categorie, sec_to_time(avg(t_piece.Duree))**
    **FROM bdasm.t_piece**
    **Right join t_categorie on t_piece.FK_Categorie = t_categorie.PK_Categorie**
    **Group by t_categorie.Categorie**
33. Affichez les durées totales par catégories des pièces (reprenez la logique TIME_TO_SEC et
SEC_TO_TIME des requêtes de la partie A)
    **SELECT t_categorie.Categorie, sec_to_time(Sum(t_piece.Duree)) Duree_total**
    **FROM bdasm.t_piece**
    **Right join t_categorie on t_piece.FK_Categorie = t_categorie.PK_Categorie**
    **Group by t_categorie.Categorie**
34. Affichez le nombre de pièces composées et informations des compositeurs pour les composi-
teurs ayant composé plus de 30 pièces
    **SELECT t_compositeur.nom, count(t_piece.Titre)**
    **FROM bdasm.t_compositeur**
    **inner join t_piece on t_piece.FK_Compositeur = t_compositeur.PK_Compositeur**
    **group by t_compositeur.Nom**
    **having count(t_piece.Titre) >= 30**
35. Affichez le nombre de pièces composées et informations des compositeurs pour les compositeurs
ayant composé entre 10 et 20 pièces
    **SELECT t_compositeur.nom, count(t_piece.Titre)**
    **FROM bdasm.t_compositeur**
    **inner join t_piece on t_piece.FK_Compositeur = t_compositeur.PK_Compositeur**
    **group by t_compositeur.Nom**
    **having count(t_piece.Titre) between 10 and 20**
36. Affichez le nom du compositeur qui a composé le plus d’œuvres
    **SELECT t_compositeur.nom, count(t_piece.Titre)**
    **FROM bdasm.t_compositeur**
    **inner join t_piece on t_piece.FK_Compositeur = t_compositeur.PK_Compositeur**
    **group by t_compositeur.Nom**
    **order by count(t_piece.Titre) desc**
    **limit 1**
37. Affichez le nom, prénom du client, date et montant complet pour chaque commande


```
SELECT t_client.nom, t_client.Prenom ,t_commande.Date, sum(t_piece.Prix *
t_detailcommande.Quantite) As Prix
from t_client
inner join t_commande on t_client.PK_Client = t_commande.FK_Client
inner join t_detailcommande on t_detailcommande.FK_Commande =
t_commande.PK_Commande
inner join t_piece
on t_piece.PK_Piece = t_detailcommande.FK_Piece
group by t_client.nom
```
38. Affichez le chiffre d’affaire des commandes réalisées par années (utilisez la fonction YEAR())
    **SELECT YEAR(t_commande.date), sum(t_piece.Prix * t_detailcommande.Quantite)**
    **As Chiffre_D_Affaire**
    **from t_commande**
    **inner join t_detailcommande on t_detailcommande.FK_Commande =**
    **t_commande.PK_Commande**
    **inner join t_piece**
    **on t_piece.PK_Piece = t_detailcommande.FK_Piece**
    **group by YEAR(t_commande.date)**
39. Affichez les commandes (date et montant) réalisées par « Bruno GAUTIER »
    **SELECT t_client.nom, t_client.Prenom ,t_commande.Date, sum(t_piece.Prix ***
    **t_detailcommande.Quantite) As Prix**
    **from t_client**
    **inner join t_commande on t_client.PK_Client = t_commande.FK_Client**
    **inner join t_detailcommande on t_detailcommande.FK_Commande =**
    **t_commande.PK_Commande**
    **inner join t_piece**
    **on t_piece.PK_Piece = t_detailcommande.FK_Piece**
    **group by t_client.nom**
    **having t_client.Nom = "gautier" and t_client.Prenom = "Bruno"**
40. Affichez les détails (nom, prénom du client, montant, date) des commandes de plus de 5000.-
    **SELECT t_client.nom, t_client.Prenom ,t_commande.Date, sum(t_piece.Prix ***
    **t_detailcommande.Quantite) As Prix**
    **from t_client**
    **inner join t_commande on t_client.PK_Client = t_commande.FK_Client**
    **inner join t_detailcommande on t_detailcommande.FK_Commande =**
    **t_commande.PK_Commande**
    **inner join t_piece**
    **on t_piece.PK_Piece = t_detailcommande.FK_Piece**
    **group by t_client.nom**
    **having Prix >= "5000"**
42. Faites une requête qui ajoute un X à la fin de toutes les abréviations de maison d’éditions qui
    ont exactement 3 caractères (utilisez la fonction CONCAT pour concaténer 2 chaines)
    **Update t_edition**
    **set t_edition.Abreviation = concat(t_edition.Abreviation,"X")**
    **Where length(t_edition.Abreviation) = 3**
43. Faites une requête qui remplace le ‘X’ ajouté dans la requête précédente par un ‘Y’. Attention, ne
faites ceci QUE pour les abréviations qui se terminent par un « X » et qui ont 4 caractères (l’abrévia-
tion « Ox » ne doit pas être renommée « OY » !). Utilisez la fonction SUBSTRING pour enlever un ca-
ractère à une chaine de caractères.
    **Update t_edition**
    **Set Abreviation = concat(substring(Abreviation, 1,3),”Y”)**
    **Where Abreviation like “%X” and char_length(Abreviation) = 4**
44. Faites une requête qui enlève le « Y » à la fin de toutes les abréviations qui terminent par « Y »
(pour revenir dans la situation initiale)
    **Update t_edition**
    **Set Abreviation = substring(Abreviation,1, char_length(Abreviation)-1)**
    **Where Abreviation like “%Y”**
45. Ajoutez manuellement (ou à l’aide d’un INSERT) une maison d’édition « Test » (abréviation :
« tst » et PK_Edition : 198)
    **INSERT INTO `bdasm`.`t_edition` (`PK_Edition`, `Abreviation`, `Edition`)**
    **VALUES ('198', 'tst', 'Test');**


46. Faites ensuite une requête qui efface toutes les maisons d’édition qui ont un nom qui commence
et qui termine par la lettre « t » (seule la maison d’édition ajoutée précédemment devrait être con-
cernée !)
    **Delete from t_edition**
    **Where Edition like “t%t”**

## 18 Ajouter, Modifier, Supprimer

#### 18.1.1 Avant

Avant de commencer à modifier notre base de données, nous devons taper une commande
pour avoir l’autorisation de la modifier.

```
SET SQL_SAFE_UPDATES=0;
```
#### 18.1.2 Insert

Pour rajouter des données dans la base, on utilise la commande insert into.
Exemple :

```
INSERT INTO `bdasm`.`t_edition` (`PK_Edition`, `Abreviation`, `Edition`)
VALUES ('198', 'tst', 'Test');
```
#### 18.1.3 Update

Pour mettre à jour 1 ou plusieurs champs, on utilise la commande Update.
Exemple :

```
Update t_edition
set t_edition.Abreviation = concat(t_edition.Abreviation,"X")
Where length(t_edition.Abreviation) = 3
```
#### 18.1.4 Delete

Pour supprimer un champ ou plusieurs champs on utilise la commande Delete from.
Exemple :

```
Delete from t_edition
Where Edition like “t%t”
```
## 19 Accroche Aqua splash

### 19.1 Schém a patte d’oie


### 19.2 Requête

1. Prénom de l’employé qui gère le revendeur ayant passé le plus de commandes.

```
SELECT t_employe.prenom, t_employe.nom,count(t_revendeur.nom)
FROM acquaspash.t_revendeur
Inner join t_commande on t_revendeur.PK_Revendeur = t_commande.FK_Revendeur
Inner join t_employe on t_revendeur.FK_Contact = t_employe.PK_Employe
Group by t_revendeur.nom, t_employe.Nom, t_employe.Prenom
order by count(PK_Commande) desc
limit 1
```
2. Nom du dernier employé (en triant alphabétiquement) qui n’est remplaçant de personne.

```
SELECT Employe.Nom, Remplacant.Nom
FROM t_employe Employe
Right join t_employe as Remplacant on Employe.FK_Remplacant =
Remplacant.PK_Employe
Where Employe.FK_Remplacant is null
order by Remplacant.Nom desc
limit 1
```
3. Le premier mot du type de l’article ayant été commandé en moins grande quantité au
    total (mais tout de même commandé au moins une fois)

```
SELECT Nom, t_type.Type, sum(Quantite)
FROM t_article
inner join tr_commande_article on PK_Article = FK_Article
inner join t_type on PK_Type = FK_Type
group by t_article.Nom, t_type.Type
order by Sum(Quantite) asc
limit 1
```
4. La commande SQL pour modifier des données

```
Update
```
5. Le premier mot du nom de l’article le plus cher


```
Select Nom from t_article order by Prix desc
Limit 1
```
6. La localité qui a le plus de revendeurs

```
Select t_localite.Localite, Count(PK_revendeur)
From t_localite
Inner join t_revendeur on fk_localite = pk_localite
Group by t_localite.Localite
Order by Count(PK_revendeur) desc
Limit 1
```
7. La commande SQL pour rechercher des données.

```
Select
```
8. La commande SQL pour effacer des données

```
Delete
```
9. Le nom du type le plus présent dans la liste des articles

```
Select t_type.Type, Count(PK_Article)
From T_Type
Inner join t_article on fk_type = pk_type
Group by type
Order by count(PK_Article)
Limit 1
```
10. Le nom du type le moins présent dans la liste des articles.

```
Select t_type.Type, Count(PK_Article)
From T_Type
Left join t_article on fk_type = pk_type
Group by type
Order by count(PK_Article)
Limit 1
```
11. Le premier mot du nom du revendeur ayant investi le moins d’argent en commandes.

```
SELECT t_revendeur.Nom, sum(Prix*Quantite)
FROM t_revendeur
inner join t_commande on FK_Revendeur = PK_Revendeur
inner join tr_commande_article on FK_Commande = PK_Commande
inner join t_article on FK_Article = PK_Article
group by t_revendeur.Nom
order by sum(Prix*Quantite)
limit 1
```
## 20 Exercice Asterix

### 20.1 Schéma pa tte d’oie


### 20.2 Requête

#### 20.2.1 Modifications

```
Avant de faire cette partie, activez la commande suivante :
SET SQL_SAFE_UPDATES = 0;
```
32. Augmentez de 10% le prix de tous les albums moins chers que 17.00
    **Update t_album**
    **set t_album.Prix = prix + (0.1 * prix)**
    **where prix < 17.00**
33. Inscrivez ‘-‘ dans le champ « Presentation » de chaque personnage n’ayant pas de présentation
    **Update t_personnage**
    **set t_personnage.Presentation = "-"**
    **Where Presentation = ""**

## 21 Exercice Formatif

### 21.1 Patte d’oie


### 21.2 Requête

N’oubliez pas tout d’abord d’activer le mode ONLY_FULL_GROUP_BY avec
set sql_mode = 'NO_ENGINE_SUBSTITUTION,ONLY_FULL_GROUP_BY';

1. Affichez le nom, prénom et commune d’habitation pour chaque employé, trié par taux
    horaire.
2. Affichez le Nom, Prénom et fonction (si l’employé a bien une fonction) de chaque employé
    ainsi que le nom et prénom de son chef (si l’employer a bien un chef). Les employés sans
    fonction ou sans chefs doivent aussi être présents dans la liste.
3. Affichez la liste des contrôles (avec la date, durée du contrôle, nom et localité de l’instal-
    lation contrôlés) réalisés par l’employé « Bernard Bailly »), triée du contrôle le plus récent
    au plus ancien.


4. Affichez le nombre d’installations par commune, pour toutes les communes ayant au

```
moins 10 installations.
```
5. Affichez les prénoms et noms des 4 employés qui ont réalisé le plus de contrôles.
6. Affichez le nombre d’employés et le taux horaire moyen par fonctions (attention : les em-

```
ployés qui n’ont pas de fonction doivent aussi être pris en considération).
```
7. Affichez le prix total de tous les contrôles (sommes des heures de contrôles * les taux
    horaires) réalisés sur la commune de « Versoix ».
8. Affichez le chiffre d’affaire (somme des heures * taux horaire) généré par chaque employé

```
classé du plus haut chiffre d’affaire au plus bas.
```

9. Affichez la liste des contrôles (date du contrôle, nom de l’installation, commune concernée
    et prénom/nom de l’employé) qui ont été réalisés dans la commune d’habitation du con-
    trôleur concerné, trié du contrôle le plus récent au plus ancien.
10. Affichez la liste des installations de catégorie « Patinoire » se trouvant soit à « GENEVE »,

```
soit à « CAROUGE », soit à « VERNIER ».
```
11. Affichez le nombre d’installations par catégorie se trouvant dans la commune de « GE-

```
NEVE », classé de la catégorie la plus présente à la moins présente.
```
12. Affichez la liste des installations dont le nom contient « multisport » et qui se trouvent dans

```
la commune de « ONEX » ou de « CHOULEX »
```
13. Affichez la liste des installations qui contiennent le nom de leur commune dans le nom.
    Astuces : le nom de la commune est toujours écrit en majuscule (utilisez upper ou lower
       pour mettre tout en majuscule ou minuscule).
    La méthode concat vous permet de créer une chaine de caractères concaténée.


14. Affichez le nom et prénom de l'employé qui prend en moyenne le moins de temps à faire
    ses contrôles

Requêtes de modifications à réaliser :
Rendez d’abord la modification possible avec SET SQL_SAFE_UPDATES = 0 ;

15. Le taux horaire de tous les employés ayant un taux inférieur à 40.- subissent une aug-
    mentation de 5%
16. Effacez tous les contrôles qui n’ont duré qu’une heure

## 22 Exercice Formatif 2

### 22.1 Schéma patte d’oie


### 22.2 Requête

- Le nom des volcans, leur pays et leur roche (pour ceux qui en ont une) pour tous les vol-
    cans en activité (activité « Eruption Dated »).
**select t_volcan.Nom, t_pays.Pays, t_roche.Roche, t_activite.Activite from
t_volcan
inner join t_pays on t_pays.PK_Pays = t_volcan.FK_Pays
left join t_roche on t_roche.PK_Roche = t_volcan.FK_Roche
inner join t_activite on t_activite.PK_Activite = t_volcan.FK_Activite
Where t_activite.Activite like "Eruption Dated"**
- La liste des pays qui n’ont pas de volcans.
    **select t_pays.Pays from t_volcan**
    **right join t_pays on t_pays.PK_Pays = t_volcan.FK_Pays**
    **Where t_volcan.FK_Pays is null**
- Le nombre de volcans par type de roche classé du plus représenté au moins représenté.
    **select t_typevolcan.Type, count(t_volcan.PK_Volcan) as NBR from t_volcan**
    **inner join t_typevolcan on t_typevolcan.PK_TypeVolcan =**
    **t_volcan.FK_TypeVolcan**
    **group by t_typevolcan.type**


```
order by NBR desc
```
- Le nombre d’éruptions par volcan pour tous les volcans ayant eu au plus de 10 érup-
    tions.
**select t_volcan.Nom, count(t_eruption.PK_Eruption) as NBR from t_volcan
inner join t_eruption on t_eruption.FK_Volcan = t_volcan.PK_Volcan
group by t_volcan.Nom, PK_volcan
having nbr > 10**
- L’altitude moyenne des volcans italiens.
    **select t_pays.Pays, avg(t_volcan.Altitude) as NBR from t_volcan**
    **inner join t_pays on t_volcan.FK_Pays = t_pays.PK_Pays**
    **where t_pays.Pays like "Italy"**
    **group by t_pays.pays**
- La liste (sans doublon) des volcans qui après 1990 ont provoqué au moins une fois un
    événement de type « Tsunami » lors d’une éruption.
    **select t_volcan.Nom, t_eruption.Annee, t_typeevenement.TypeEvenement from**
    **t_volcan**
    **inner join t_eruption on t_eruption.FK_Volcan = t_volcan.PK_Volcan**
    **inner join tr_eruption_typeevenement on**
    **tr_eruption_typeevenement.PFK_Eruption = t_eruption.PK_Eruption**
    **inner join t_typeevenement on t_typeevenement.PK_TypeEvenement =**
    **tr_eruption_typeevenement.PFK_TypeEvenement**
    **where t_typeevenement.TypeEvenement like "Tsunami" and Annee> 1900**
- La liste des publications (titre, auteurs et année) qui contiennent le mot « Vesuvius »
    dans le titre et le nom « Sulpizio » dans les auteurs, trié de la plus récente à la plus an-
    cienne.
    **select t_publication.Auteurs, t_publication.Titre,**
    **t_publication.AnneePublication from t_publication**
    **where Titre like "%Vesuvius%" and Auteurs like "%Sulpizio%"**
    **order by AnneePublication desc**
- La liste de toutes les commandes (de la plus ancienne à la plus récente, affichez les
    dates et les montants) réalisées par le client « Maurice Kraft » avec le montant à payer
    pour chaque commande
    **select t_client.Nom, t_client.Prenom, t_commande.DateCommande as**
    **Date,sum(t_typeclient.TauxFacturation*t_detailcommande.Quantite**
    ***t_publication.Prix) as Montant from t_client**
    **inner join t_typeclient on t_client.FK_TypeClient =**
    **t_typeclient.PK_TypeClient**
    **inner join t_commande on T_commande.FK_Client = t_client.PK_Client**
    **inner join t_detailcommande on t_detailcommande.FK_Commande =**
    **t_commande.PK_Commande**
    **inner join t_publication on t_publication.PK_Publication =**
    **t_detailcommande.FK_Publication**
    **Where Nom like "Kraft" and Prenom like "Maurice"**
    **group by PK_Commande, dateCommande**
    **order by Date asc**
- Les 5 plus grosses commandes (date et montants) du client « Piotr Silakis »
    **select t_client.Nom, t_client.Prenom, t_commande.DateCommande as**
    **Date,sum(t_typeclient.TauxFacturation*t_detailcommande.Quantite**
    ***t_publication.Prix) as Montant from t_client**
    **inner join t_typeclient on t_client.FK_TypeClient =**
    **t_typeclient.PK_TypeClient**
    **inner join t_commande on T_commande.FK_Client = t_client.PK_Client**
    **inner join t_detailcommande on t_detailcommande.FK_Commande =**
    **t_commande.PK_Commande**
    **inner join t_publication on t_publication.PK_Publication =**
    **t_detailcommande.FK_Publication**
    **Where Nom like "Silakis" and Prenom like "Piotr"**
    **group by PK_commande, DateCommande**
    **order by Montant desc**
    **limit 5**
- La liste de toutes les commandes (nom, prénom du client, date et montant de la com-
    mande) plus grande que 4500 CHF


```
select t_client.Nom, t_client.Prenom, t_commande.DateCommande as
Date,sum(t_typeclient.TauxFacturation*t_detailcommande.Quantite
*t_publication.Prix) as Montant from t_client
inner join t_typeclient on t_client.FK_TypeClient =
t_typeclient.PK_TypeClient
inner join t_commande on T_commande.FK_Client = t_client.PK_Client
inner join t_detailcommande on t_detailcommande.FK_Commande =
t_commande.PK_Commande
inner join t_publication on t_publication.PK_Publication =
t_detailcommande.FK_Publication
group by Nom, Prenom, DateCommande, PK_Commande
having Montant > 4500
order by montant desc
```
- La liste de toutes les commandes (nom, prénom du client, date, montant et rabais grâce
    au taux de facturation) pour toutes les commandes réalisées par des étudiants et ayant
    bénéficié d’un rabais (grâce au taux de facturation) de plus 1000 CHF
**select t_client.Nom, t_client.Prenom, t_commande.DateCommande as
Date,sum(t_typeclient.TauxFacturation*t_detailcommande.Quantite
*t_publication.Prix) as Montant, sum(t_detailcommande.Quantite
*t_publication.Prix) -
sum(t_typeclient.TauxFacturation*t_detailcommande.Quantite
*t_publication.Prix) as Rabais from t_client
inner join t_typeclient on t_client.FK_TypeClient =
t_typeclient.PK_TypeClient
inner join t_commande on T_commande.FK_Client = t_client.PK_Client
inner join t_detailcommande on t_detailcommande.FK_Commande =
t_commande.PK_Commande
inner join t_publication on t_publication.PK_Publication =
t_detailcommande.FK_Publication
where t_typeclient.Type like "Etudiant"
group by Nom, Prenom, DateCommande, PK_Commande
having Rabais > 1000
order by Rabais desc**
- La liste des clients avec le nom et prénom de leur professeur (attention, les clients qui
    n’ont pas de professeur doivent également être affichés)
**select t_client.Nom, t_client.Prenom, prof.nom, prof.prenom from t_client
left join t_client as prof on t_client.FK_Professeur = prof.PK_Client**
- La liste des clients (prénom, nom, pays et type) ayant « Haroun Tazieff » comme profes-
    seur
**select t_client.Nom, t_client.Prenom,t_pays.Pays, t_typeclient.Type from
t_client
left join t_client as prof on t_client.FK_Professeur = prof.PK_Client
inner join t_pays on t_client.FK_Pays = t_pays.PK_Pays
inner join t_typeclient on t_client.FK_TypeClient =
t_typeclient.PK_TypeClient
Where prof.nom like "Tazieff" and prof.Prenom like "Haroun"**
- La liste des volcans qui se trouvent dans les pays « Mexico », « Mali », « Norway » ou «
    Russia »
**select t_volcan.nom, t_pays.Pays from t_volcan
inner join t_pays on t_pays.PK_Pays = t_volcan.FK_Pays
where t_pays.pays in("Mexico","Mali","Norway","Russia")**
- La liste des éruptions (nom du volcan, année et type de l’éruption) en Italie entre 2000 et
    2015
**select t_volcan.nom, t_eruption.Annee, t_typeeruption.TypeEruption from
t_volcan
inner join t_pays on t_pays.PK_Pays = t_volcan.FK_Pays
inner join t_eruption on t_eruption.FK_Volcan = t_volcan.PK_Volcan
inner join t_typeeruption on t_eruption.FK_TypeEruption =
t_typeeruption.PK_TypeEruption
where t_pays.pays = "Italy" and Annee between 2000 and 2015**
- Toutes les publications de plus de 90 CHF subissent une baisse de 10%
    **UPDATE t_publication set Prix = Prix * 0.9 where Prix > 90**


- La cliente « Stefanie Peters » se nomme en fait « Stéphanie Peters »
    **UPDATE t_client set prenom = "Stéphanie" where nom = "Peters" and prenom =**
    **"Stefanie"**

## 23 Exercice Formatif 3

### 23.1 Schéma patte d’o ie

### 23.2 Requête

- Affichez la liste des événements se déroulant dans une station Fribourgeoise triée du
    plus récent au plus ancien.
**select t_evenement.Date, t_evenement.Prix, t_station.Nom from t_evenement
inner join t_typeevenement on t_evenement.FK_TypeEvenement =
t_typeevenement.PK_TypeEvenement
inner join t_station on t_station.PK_Station = t_evenement.FK_Station
inner join t_canton on t_canton.PK_Canton = t_station.FK_Canton
Where t_canton.nom like "Fribourg"
order by Date desc**
- Affichez le nombre d'événements par type classés du plus représenté au moins repré-
    senté (attention, si un type n'est jamais utilisé par un événement, il doit tout de même
    ressortir dans la liste)
**select count(t_evenement.PK_Evenement) as nbr,
t_typeevenement.TypeEvenement from t_typeevenement
left join t_evenement on t_evenement.FK_TypeEvenement =
t_typeevenement.PK_TypeEvenement
group by TypeEvenement
order by nbr desc**
- Affichez la liste sans doublons des événements (date, station, type d'événement) pour
    lesquels "Louis Poirier" a passé commande
**select distinct t_evenement.Date, t_station.Nom,
t_typeevenement.TypeEvenement from t_evenement
inner join t_station on t_evenement.FK_Station = t_station.PK_Station
inner join t_typeevenement on t_evenement.FK_TypeEvenement =
t_typeevenement.PK_TypeEvenement
inner join tr_commande_evenement on t_evenement.PK_Evenement =
tr_commande_evenement.PFK_Evenement**


```
inner join t_commande on t_commande.PK_Commande =
tr_commande_evenement.PFK_Commande
inner join t_client on t_client.PK_Client = t_commande.FK_Client
Where t_client.Nom = "Poirier" and t_client.Prenom = "Louis"
```
- Affichez le nom et prénom des clients ayant commandé plus de 400 billets (tout événements
    confondus)
**select t_client.nom, t_client.Prenom, sum(tr_commande_evenement.Quantite) as
NbrBillet from t_client
inner join t_commande on t_client.PK_Client = t_commande.FK_Client
inner join tr_commande_evenement on t_commande.PK_Commande =
tr_commande_evenement.PFK_Commande
group by t_client.nom, t_client.Prenom
having NbrBillet > 400**
- Affichez la liste des stations du canton de Vaud dans lesquelles aucun événement n'est organisé
    **select t_station.Nom, t_canton.Nom, t_evenement.FK_Station from t_station**
    **inner join t_canton on t_station.FK_Canton = t_canton.PK_Canton**
    **left join t_evenement on t_evenement.FK_Station = t_station.PK_Station**
    **where FK_Station is null and t_canton.nom = "Vaud"**
- Affichez le nom des 2 stations du canton du Valais dans lesquelles le plus d'événements sont or-
    ganisés
    **select t_station.Nom, t_canton.Nom, count(t_evenement.PK_Evenement) as**
    **NbrEvent from t_station**
    **inner join t_canton on t_station.FK_Canton = t_canton.PK_Canton**
    **inner join t_evenement on t_evenement.FK_Station = t_station.PK_Station**
    **where t_canton.nom = "Valais"**
    **group by t_station.Nom, t_canton.Nom**
    **order by NbrEvent desc**
    **limit 2**
- Affichez la liste des clients et le nom de leur parrain pour ceux qui ont un parrain venant du
    même canton qu'eux.
    **select cl.Nom, Parrain.Nom from t_client as cl**
    **inner join t_client as Parrain on cl.FK_Parrain = Parrain.PK_Client**
    **where cl.FK_Canton = Parrain.FK_Canton**
- Affichez la liste des commandes (PK de la commande et la somme à payer) pour les commandes
    réalisées par "Emma Girard" (attention, n'oubliez pas d'appliquer le rabais en fonction du type
    de client).
    **select t_commande.PK_Commande, sum(t_evenement.Prix ***
    **tr_commande_evenement.Quantite*(100-t_typeclient.PourcentRabais)/100) from**
    **t_commande**
    **inner join tr_commande_evenement on t_commande.PK_Commande =**
    **tr_commande_evenement.PFK_Commande**
    **inner join t_evenement on t_evenement.PK_Evenement =**
    **tr_commande_evenement.PFK_Evenement**
    **inner join t_client on t_client.PK_Client = t_commande.FK_Client**
    **inner join t_typeclient on t_client.FK_TypeClient =**
    **t_typeclient.PK_TypeClient**
    **where t_client.Nom = "Girard" and t_client.Prenom = "Emma"**
    **group by t_commande.PK_Commande**
- Affichez le prix sans rabais, le prix avec rabais et le montant du rabais que représentent les
    achats de billets pour des événements qui se déroulent dans la station de "Evolène".
    **SELECT sum(Quantite * Prix) as totalSansRabais,**
    **sum(Quantite * Prix * (100-PourcentRabais) / 100) as totalAvecRabais,**
    **sum(Quantite * Prix)-sum(Quantite * Prix * (100-PourcentRabais) / 100)**
    **as montantRabais**
    **from t_commande**
    **inner join t_client on fk_client = pk_client**
    **inner join t_typeclient on fk_typeclient = pk_typeclient**
    **inner join tr_commande_evenement on pfk_commande = pk_commande**
    **inner join t_evenement on pfk_evenement = pk_evenement**
    **inner join t_station on fk_station = pk_station**
    **where t_station.Nom="Evolène"**


- Affichez la liste des commandes (PK de la commande, nom et prénom du client et la somme à
    payer) pour les commandes réalisées qui concernent au moins un événement se déroulant dans
    la station "Les Crosets" (attention, n'oubliez pas d'appliquer le rabais en fonction du type de
    client).
**select t_commande.PK_Commande, t_client.Nom, t_client.Prenom,
sum(tr_commande_evenement.Quantite*t_evenement.Prix*(100-
t_typeclient.PourcentRabais)/100) from t_client
inner join t_typeclient on t_typeclient.PK_TypeClient =
t_client.FK_TypeClient
inner join t_commande on t_client.PK_Client = t_commande.FK_Client
inner join tr_commande_evenement on tr_commande_evenement.PFK_Commande =
t_commande.PK_Commande
inner join t_evenement on t_evenement.PK_Evenement =
tr_commande_evenement.PFK_Evenement
inner join t_station on t_station.PK_Station = t_evenement.FK_Station
where t_station.nom = "Les Crosets"
group by t_commande.PK_Commande, t_client.Nom**
- Affichez le détail de la commande ayant la pk 59 (pour chaque événement le nom de la station,
    la date et le type de l'événement ainsi que la quantité commandée)
select t_commande.PK_Commande, t_station.Nom,t_evenement.Date,
t_typeevenement.TypeEvenement, tr_commande_evenement.Quantite from t_commande
inner join tr_commande_evenement on t_commande.PK_Commande =
tr_commande_evenement.PFK_Commande
inner join t_evenement on t_evenement.PK_Evenement =
tr_commande_evenement.PFK_Evenement
inner join t_station on t_station.PK_Station = t_evenement.FK_Station
inner join t_typeevenement on t_typeevenement.PK_TypeEvenement =
t_evenement.FK_TypeEvenement
where t_commande.PK_Commande = 59
- Affichez le nom, prénom et nom, prénom des parrains de tous les clients bernois. Attention, les
    clients bernois non-parrainés doivent également être exportés.
**select t_client.Nom, t_client.Prenom, Parrain.Nom, Parrain.Prenom from
t_client
left join t_client as Parrain on t_client.FK_Parrain = Parrain.PK_Client
inner join t_canton on t_canton.PK_Canton = t_client.FK_Canton
where t_canton.nom = "Berne"**
- Affichez le chiffre d'affaire des 5 stations ayant réalisé le meilleur chiffre (montant des ventes
    réalisées pour cette station en appliquant les rabais)
**SELECT t_station.Nom, sum(Quantite * Prix * (100-PourcentRabais) / 100) from
t_commande
inner join t_client on fk_client = pk_client
inner join t_typeclient on fk_typeclient = pk_typeclient
inner join tr_commande_evenement on pfk_commande = pk_commande
inner join t_evenement on pfk_evenement = pk_evenement
inner join t_station on fk_station = pk_station
group by t_station.Nom
order by sum(Quantite * Prix * (100-PourcentRabais) / 100) desc
limit 5**
- Affichez la liste des clients habitant les cantons de Berne, Neuchâtel ou Vaud et ayant un nom
    qui commence par la lettre "B".
**select * from t_client
inner join t_canton on fk_canton = pk_canton
where t_client.Nom like "B%" and t_canton.Nom in ("Berne", "Neuchâtel",
"Vaud")**
- Affichez la liste des stations qui ont le nom qui débute par la même lettre que le canton dans
    lequel elle se trouve.
    Astuce: intéressez-vous à la fonction substring.
    Exemple: substring("ModuleB20", 5, 3) retourne "leB"
**select t_station.*, t_canton.* from t_station
inner join t_canton on fk_canton = pk_canton
where substring(t_station.Nom, 1, 1) = substring(t_canton.Nom, 1, 1)**


- Appliquez une augmentation de 10% à tous les prix d'événement de moins de 25.-
    update t_evenement set Prix = Prix * 1.1

```
where Prix < 25
```
## 23 Conclusion

Ce module m’a appris beaucoup de nouvelles choses au niveau du SQL et des bases de don-
nées. Ce qui m’a le plus plu, c’est la partie SQL même si quelquefois j’ai eu un peu de peine.
Cependant, après beaucoup d’exercice, on commence à s’embête. A part ses long moment
d’exercice, le module était intéressant.

## 24 Source

Photo page de garde : https://images.app.goo.gl/VUtqUihWneJCQxnm7


